<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="T. Hellert">
<title>SC Manual</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>SC Manual</h1>
<div class="details">
<span id="author" class="author">T. Hellert</span><br>
<span id="email" class="email"><a href="mailto:thellert@lbl.gov">thellert@lbl.gov</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#_initialization">Initialization</a></li>
<li><a href="#_error_source_definition_registration">Error Source Definition &amp; Registration</a></li>
<li><a href="#_generation_of_a_machine_realization">Generation of a Machine Realization</a></li>
<li><a href="#_interaction_with_the_machine">Interaction with the Machine</a></li>
</ul>
</li>
<li><a href="#sec:err">Error Sources</a>
<ul class="sectlevel2">
<li><a href="#err:BPMs">BPMs</a></li>
<li><a href="#err:cav">Cavities</a></li>
<li><a href="#err:magnets">Magnets</a></li>
<li><a href="#err:mult">Higher order multipoles</a></li>
<li><a href="#err:inj">Injected beam</a></li>
<li><a href="#err:support">Support and Alignment</a></li>
</ul>
</li>
<li><a href="#sec:example">SC Usage Example - FODO Lattice</a>
<ul class="sectlevel2">
<li><a href="#_setup_enviroment">Setup enviroment</a></li>
<li><a href="#_define_lattice_file">Define lattice file</a></li>
<li><a href="#_initialize_toolbox">Initialize toolbox</a></li>
<li><a href="#_register_lattice_in_sc">Register lattice in SC</a></li>
<li><a href="#_define_lattice_apertures">Define lattice apertures</a></li>
<li><a href="#_check_registration">Check registration</a></li>
<li><a href="#_apply_errors">Apply errors</a></li>
<li><a href="#_setup_correction_chain">Setup correction chain</a></li>
<li><a href="#_start_correction_chain">Start correction chain</a></li>
<li><a href="#_perform_loco_based_linear_optics_correction">Perform LOCO based linear optics correction.</a></li>
</ul>
</li>
<li><a href="#sec:functions">Function Categories</a>
<ul class="sectlevel2">
<li><a href="#_initialization_2">Initialization</a></li>
<li><a href="#_tracking">Tracking</a></li>
<li><a href="#_error_model">Error Model</a></li>
<li><a href="#_visualization">Visualization</a></li>
<li><a href="#_correction_scripts">Correction Scripts</a></li>
<li><a href="#_lattice_properties">Lattice Properties</a></li>
<li><a href="#_lattice_manipulation">Lattice Manipulation</a></li>
</ul>
</li>
<li><a href="#_function_list">Function List</a>
<ul class="sectlevel2">
<li><a href="#SCBBA">SCBBA</a></li>
<li><a href="#SCapplyErrors">SCapplyErrors</a></li>
<li><a href="#SCcronoff">SCcronoff</a></li>
<li><a href="#SCdynamicAperture">SCdynamicAperture</a></li>
<li><a href="#SCfeedbackBalance">SCfeedbackBalance</a></li>
<li><a href="#SCfeedbackFirstTurn">SCfeedbackFirstTurn</a></li>
<li><a href="#SCfeedbackRun">SCfeedbackRun</a></li>
<li><a href="#SCfeedbackStitch">SCfeedbackStitch</a></li>
<li><a href="#SCfitInjectionZ">SCfitInjectionZ</a></li>
<li><a href="#SCgenBunches">SCgenBunches</a></li>
<li><a href="#SCgetBPMreading">SCgetBPMreading</a></li>
<li><a href="#SCgetBeamTransmission">SCgetBeamTransmission</a></li>
<li><a href="#SCgetCMSetPoints">SCgetCMSetPoints</a></li>
<li><a href="#SCgetCOD">SCgetCOD</a></li>
<li><a href="#SCgetDispersion">SCgetDispersion</a></li>
<li><a href="#SCgetModelDispersion">SCgetModelDispersion</a></li>
<li><a href="#SCgetModelRING">SCgetModelRING</a></li>
<li><a href="#SCgetModelRM">SCgetModelRM</a></li>
<li><a href="#SCgetOrds">SCgetOrds</a></li>
<li><a href="#SCgetPinv">SCgetPinv</a></li>
<li><a href="#SCgetRespMat">SCgetRespMat</a></li>
<li><a href="#SCgetSupportOffset">SCgetSupportOffset</a></li>
<li><a href="#SCgetSupportOffset_backup210212">SCgetSupportOffset</a></li>
<li><a href="#SCgetSupportRoll">SCgetSupportRoll</a></li>
<li><a href="#SCgetTransformation">SCgetTransformation</a></li>
<li><a href="#SCinit">SCinit</a></li>
<li><a href="#SClocoLib">SClocoLib</a></li>
<li><a href="#SCmomentumAperture">SCmomentumAperture</a></li>
<li><a href="#SCmultipolesRead">SCmultipolesRead</a></li>
<li><a href="#SCparticlesIn3D">SCparticlesIn3D</a></li>
<li><a href="#SCplotBPMreading">SCplotBPMreading</a></li>
<li><a href="#SCplotCMstrengths">SCplotCMstrengths</a></li>
<li><a href="#SCplotLattice">SCplotLattice</a></li>
<li><a href="#SCplotLattice_backup220627">SCplotLattice</a></li>
<li><a href="#SCplotPhaseSpace">SCplotPhaseSpace</a></li>
<li><a href="#SCplotSupport">SCplotSupport</a></li>
<li><a href="#SCpseudoBBA">SCpseudoBBA</a></li>
<li><a href="#SCrampUpErrors">SCrampUpErrors</a></li>
<li><a href="#SCrandnc">SCrandnc</a></li>
<li><a href="#SCregisterBPMs">SCregisterBPMs</a></li>
<li><a href="#SCregisterCAVs">SCregisterCAVs</a></li>
<li><a href="#SCregisterMagnets">SCregisterMagnets</a></li>
<li><a href="#SCregisterSupport">SCregisterSupport</a></li>
<li><a href="#SCsanityCheck">SCsanityCheck</a></li>
<li><a href="#SCscaleCircumference">SCscaleCircumference</a></li>
<li><a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></li>
<li><a href="#SCsetCavs2SetPoints">SCsetCavs2SetPoints</a></li>
<li><a href="#SCsetMags2SetPoints">SCsetMags2SetPoints</a></li>
<li><a href="#SCsetMultipoles">SCsetMultipoles</a></li>
<li><a href="#SCsynchEnergyCorrection">SCsynchEnergyCorrection</a></li>
<li><a href="#SCsynchPhaseCorrection">SCsynchPhaseCorrection</a></li>
<li><a href="#SCtuneScan">SCtuneScan</a></li>
<li><a href="#SCupdateCAVs">SCupdateCAVs</a></li>
<li><a href="#SCupdateMagnets">SCupdateMagnets</a></li>
<li><a href="#SCupdateSupport">SCupdateSupport</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Realistic simulations of the operation of a complex machine like an accelerator
not only require a good model of the beam dynamics, but also have to
acknowledge the fact that only incomplete information about the actual machine
state is available during operation, due to the many unknowns in the machine
geometry, the magnetic fields and the beam-diagnostic systems.
The <code>SC</code>
toolbox addresses this issue by making clear distinctions between machine
parameters that are accessible during operation and the parameters that go into
the beam dynamics simulation of the machine, e.g. by implementing a
transfer-function, relating magnet setpoints to the actually realized magnetic
fields.</p>
</div>
<div id="img-workflow" class="imageblock text-center">
<div class="content">
<img src="../fig_workflow.jpg" alt="fig workflow" width="900">
</div>
<div class="title">Figure 1. Schematic drawing of the workflow of the <code>SC</code> toolkit.</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Typical usage of the <code>SC</code> toolbox follows the steps</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initialization of the <code>SC</code> core structure</p>
</li>
<li>
<p>Error source definition &amp; registration of elements</p>
</li>
<li>
<p>Generation of a machine realization including errors</p>
</li>
<li>
<p>Interaction with the machine</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>which are described in the following. Thereafter we describe the <a href="#sec:err">definition of error sources</a>, followed by a <a href="#sec:example">usage example</a> for a complete correction chain and a <a href="#sec:functions">list</a> of all implemented functions.</p>
</div>
<div class="sect2">
<h3 id="_initialization">Initialization</h3>
<div class="paragraph">
<p>In a first step, the user initializes the toolbox by calling <a href="#SCinit">SCinit</a> with the
AT lattice of his or her machine as input.  This sets up a matlab-structure,
usually assigned the variable name <code>SC</code>, with which nearly all subsequent
functions of the toolbox interact.  Within this central structure all relevant
information about the machine and the error sources is stored.</p>
</div>
</div>
<div class="sect2">
<h3 id="_error_source_definition_registration">Error Source Definition &amp; Registration</h3>
<div class="paragraph">
<p>In the next step, the user registers elements like magnets, BPMs or cavities
including all error sources they would like to
consider in the <code>SC</code> structure, using the <code>SCregister*</code> function family.
The <code>SCregister*</code> functions typically take the ordinates of the elements in
the lattice (see <a href="#SCgetOrds">SCgetOrds</a>) and values for the uncertainties for any of the parameters used by
the <code>AT</code> tracking code, as well as some parameters specific to <code>SC</code> 's error
model as input.</p>
</div>
<div class="paragraph">
<p>The uncertainties are given as additional name-value pairs to the <code>SCregister*</code> function, while the name reflects the field name to which the error eventually should be applied. All cavities, BPMs, magnets and support structures can be registered element- or group-wise.</p>
</div>
<div class="paragraph">
<p>Element ordinates and uncertainties are centrally stored in <code>SC.SIG</code> and <code>SC.ORD</code>, respectively, and auxiliary fields in the lattice elements are initialized. Fields in <code>SC.ORD</code> may include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BPM: Array with all registered BPM ordinates (<a href="#SCregisterBPMs">SCregisterBPMs</a>)</p>
</li>
<li>
<p>Magnet: Array with all registered magnet ordinates (<a href="#SCregisterMagnets">SCregisterMagnets</a>)</p>
</li>
<li>
<p>Cavity: Array with all registered cavity ordinates (<a href="#SCregisterCAVs">SCregisterCAVs</a>)</p>
</li>
<li>
<p>CM: Array with all registered horizontal and vertical corrector magnets ordinates (<a href="#SCregisterMagnets">SCregisterMagnets</a>)</p>
</li>
<li>
<p>SkewQuad: Array with all registered skew quadrupole corrector magnets ordinates (<a href="#SCregisterMagnets">SCregisterMagnets</a>)</p>
</li>
<li>
<p>Girder: Array with registered girder start and end ordinates (<a href="#SCregisterSupport">SCregisterSupport</a>)</p>
</li>
<li>
<p>Section: Array with registered section start and end ordinates (<a href="#SCregisterSupport">SCregisterSupport</a>)</p>
</li>
<li>
<p>Plinth: Array with registered plinth start and end ordinates (<a href="#SCregisterSupport">SCregisterSupport</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Further, <code>SCregister*</code> functions are used to specify advanced properties of the
elements which are subsequently accounted for by the toolbox; for instance the
user here specifies which magnets are ``split''- or combined-function magnets, or which
magnets should be used as a dipole or skew quadrupole correctors including their limits etc.
The function <a href="#SCplotLattice">SCplotLattice</a> visualizes the lattice properties
including the registration of magnets and diagnostic devices.
The function <a href="#SCsanityCheck">SCsanityCheck</a> helps identifying unreasonable registration of elements.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generation_of_a_machine_realization">Generation of a Machine Realization</h3>
<div class="paragraph">
<p>Errors are randomly generated based on the uncertainties stored in <code>SC.SIG</code>
and applied to the lattice via <a href="#SCapplyErrors">SCapplyErrors</a>.
By default, errors are modeled to follow a 2 <code>sigma</code>-truncated Gaussian
distribution, where <code>sigma</code> is the value specified in <code>SC.SIG</code>. The actual realization of misalignments
can be viewed by calling <a href="#SCplotSupport">SCplotSupport</a>.</p>
</div>
<div class="paragraph">
<p>Multiple calls to <a href="#SCapplyErrors">SCapplyErrors</a> produce a family of lattice realizations
following the same error distribution, allowing to comfortably set up
Monte-Carlo tolerance studies. See <a href="#sec:err">error descriptions</a> for a detailed list of considerd error sources.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interaction_with_the_machine">Interaction with the Machine</h3>
<div class="paragraph">
<p>The operator / the control system of a particle accelerator
only has incomplete information about the state of the machine and can
influence the beam only indirectly.
To account for this circumstance the <code>SC</code> toolbox implements the function
<code>SCgetBPMreading</code> and the function family <code>SCset*2SetPoints</code> for <a href="#SCsetCMs2SetPoints">CMs</a>, <a href="#SCsetCavs2SetPoints">cavities</a>, and other <a href="#SCsetMags2SetPoints">magnets</a>.</p>
</div>
<div class="paragraph">
<p><a href="#SCgetBPMreading">SCgetBPMreading</a> models the process of injecting a bunch into the machine
and observing the readings of the BPMs previously defined by <a href="#SCregisterBPMs">SCregisterBPMs</a>,
taking into account <a href="#err:inj">injection errors</a>, BPM offsets, BPM calibration errors,
and more as described in the <a href="#sec:err">error descriptions</a>.</p>
</div>
<div id="sec:inj" class="paragraph">
<p>All information regarding the injection pattern are centrally stored in the
<code>SC.INJ</code> structure, which includes the fields</p>
</div>
<div class="ulist">
<ul>
<li>
<p>nParticles:
Number of particles for tracking.</p>
</li>
<li>
<p>nTurns:
Number of turns for tracking.</p>
</li>
<li>
<p>nShots:
Number of injections used for averaging the BPM readings.</p>
</li>
<li>
<p>beamLostAt:
Fraction of particles below which a BPM does not return a proper reading anymore but a beam loss</p>
</li>
<li>
<p>Z0ideal:
[6 x 1] array defining the ideal injection vector.</p>
</li>
<li>
<p>Z0:
[6 x 1] array defining the current injection vector.</p>
</li>
<li>
<p>beamSize:
[6 x 6] array defining the beam sigma matrix.</p>
</li>
<li>
<p>randomInjectionZ:
[6 x 1] array defining the shot-to-shot injection jitter.</p>
</li>
<li>
<p>trackMode:
String defining the tracking mode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Possible tracking modes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>'TBT'</code> (turn-by-turn):
A bunch is tracked for the specified number of turns and the readings of the BPMs in each individual turn are returned.</p>
</li>
<li>
<p><code>'pORB'</code> (pseudo-orbit mode):
The BPM readings are averaged over the turns, giving a good estimate of the orbit, without having actually achieved stored beam.</p>
</li>
<li>
<p><code>'ORB'</code> (orbit mode):
It is assumed that stored beam has been achieved, so that the <code>AT</code> function <code>findorbit6</code> can be used to determine the orbit and BPM errors are applied. <code>nTurns</code> and <code>nParticles</code> are obsolete in this tracking mode</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Members of the <code>SCset*2SetPoints</code> family model the process of assigning the
set point of an experimentally accessible variable in the control system of the
accelerator, for instance the strength of a quadrupole magnet. Based on these
setpoints the actual simulation parameters going into the <code>AT</code>
tracking routine are calculated by a subsequent call to, for instance, the
<a href="#SCupdateMagnets">SCupdateMagnets</a> function.
This mechanism provides a powerful layer of abstraction, which also allows to
easily extend and modify the underlying error models during further development
of the toolbox, without the need to modify any existing user-side code.</p>
</div>
<div class="paragraph">
<p>All commissioning routines implemented in <code>SC</code> exclusively use these functions
to interact with the machine, so that the commissioning simulation is conducted
from the point of view of a real-world operator.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:err">Error Sources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following will give an overview of the error sources considered in the <code>SC</code> toolbox.</p>
</div>
<div class="sect2">
<h3 id="err:BPMs">BPMs</h3>
<div class="paragraph">
<p>The BPM errors are stored in fields of the corresponding BPM lattice element and include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Noise:
[1 x 2] array of horizontal and vertical turn-by-turn BPM noise.</p>
</li>
<li>
<p>NoiseCO:
[1 x 2] array of horizontal and vertical stored beam BPM noise.</p>
</li>
<li>
<p>CalError:
[1 x 2] array of horizontal and vertical BPM calibration errors.</p>
</li>
<li>
<p>Offset:
[1 x 2] array of horizontal and vertical individual BPM offsets.</p>
</li>
<li>
<p>SupportOffset:
[1 x 2] array of horizontal and vertical <a href="#err:support">support structure (girder) offsets</a> w.r.t. the design coordinate frame at the location of the BPMs.</p>
</li>
<li>
<p>Roll:
Individual BPM rolls</p>
</li>
<li>
<p>SupportRoll:
<a href="#err:support">Support structure (girder) roll</a> w.r.t. the design coordinate frame at the location of the BPMs.</p>
</li>
<li>
<p>SumError:
Calibration error of the sum signal. The sum signal is used to determine the beam loss location with a cutoff as defined <code>SC.INJ.beamLostAt</code> (see <a href="#sec:inj">injection pattern</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See also <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCupdateSupport">SCupdateSupport</a> and <a href="#SCregisterBPMs">SCregisterBPMs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="err:cav">Cavities</h3>
<div class="paragraph">
<p>The cavity errors are stored in fields of the corresponding cavity lattice element and include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>VoltageOffset:
Offset of cavity voltage w.r.t. to the voltage setpoint</p>
</li>
<li>
<p>VoltageCalError:
Calibration error of cavity voltage w.r.t. to the voltage setpoint</p>
</li>
<li>
<p>FrequencyOffset:
Offset of cavity frequency w.r.t. to the frequency setpoint</p>
</li>
<li>
<p>FrequencyCalError:
Calibration error of cavity frequency w.r.t. to the frequency setpoint</p>
</li>
<li>
<p>TimeLagOffset:
Offset of cavity time lag w.r.t. to the time lag setpoint</p>
</li>
<li>
<p>TimeLagCalError:
Calibration error of cavity time lag w.r.t. to the time lag setpoint</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The cavity fields used for tracking by <code>AT</code>, for example <code>Frequency</code>, are calculated by
<a href="#SCupdateCAVs">SCupdateCAVs</a> considering the current setpoint <code>FrequencySetPoint</code>, calibration
errors <code>FrequencyCalError</code> and offset <code>FrequencyOffset</code> according to</p>
</div>
<div class="paragraph">
<p><code>Frequency</code> = (1 + <code>FrequencyCalError</code>) * <code>FrequencySetPoint</code> + <code>FrequencyOffset</code>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCregisterCAVs">SCregisterCAVs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="err:magnets">Magnets</h3>
<div class="paragraph">
<p>The magnet errors are stored in fields of the corresponding magnet lattice element and include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CalErrorB:
[1 x N] array of calibration errors of the <code>PolynomB</code> fields w.r.t. the corresponding setpoints.</p>
</li>
<li>
<p>CalErrorA:
[1 x N] array of calibration errors of the <code>PolynomA</code> fields w.r.t. the corresponding setpoints.</p>
</li>
<li>
<p>PolynomBOffset:
[1 x N] array of offset errors of the <code>PolynomB</code> fields w.r.t. the corresponding setpoints.</p>
</li>
<li>
<p>PolynomAOffset:
[1 x N] array of offset errors of the <code>PolynomA</code> fields w.r.t. the corresponding setpoints.</p>
</li>
<li>
<p>MagnetRoll:
[1x3] array [az,ax,ay] defineing roll (around z-axis), pitch (roll around x-axis) and yaw (roll around y-axis) angle error of magnet (w.r.t. <a href="#err:support">support structure</a>).</p>
</li>
<li>
<p>SupportRoll:
[1x3] array [az,ax,ay] defineing roll (around z-axis), pitch (roll around x-axis) and yaw (roll around y-axis) angle error of magnet <a href="#err:support">support structure</a> w.r.t. the design coordinate frame..</p>
</li>
<li>
<p>SupportOffset:
[1 x 3] array [dx,dy,dz] of horizontal, vertical and longitudinal offset errors of magnet <a href="#err:support">support structure</a> w.r.t. the design coordinate frame.</p>
</li>
<li>
<p>MagnetOffset:
[1 x 3] array [dx,dy,dz] of horizontal, vertical and longitudinal offset errors of magnet (w.r.t. <a href="#err:support">support structure</a>).</p>
</li>
<li>
<p>T1:
[6 x 1] array of offsets w.r.t. the design coordinate frame which are added at to the particle coordinates at the entrance of the lattice element (standard AT field). Calculated from current magnet misalignments via  <a href="#SCgetTransformation">SCgetTransformation</a>.</p>
</li>
<li>
<p>T2:
[6 x 1] array of offsets w.r.t. the design coordinate frame which are added at to the particle coordinates at the exit of the lattice element (standard AT field). Calculated from current magnet misalignments via  <a href="#SCgetTransformation">SCgetTransformation</a>.</p>
</li>
<li>
<p>R1:
[6 x 6] rotation matrix w.r.t. the design coordinate frame which is multiplied with the particle coordinates at the entrance of the lattice element (standard AT field). Calculated from current magnet misalignments via  <a href="#SCgetTransformation">SCgetTransformation</a>.</p>
</li>
<li>
<p>R2:
[6 x 6] rotation matrix w.r.t. the design coordinate frame which is multiplied with the particle coordinates at the exit of the lattice element (standard AT field). Calculated from current magnet misalignments via  <a href="#SCgetTransformation">SCgetTransformation</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#SCregisterMagnets">SCregisterMagnets</a> for a list of all <code>SC</code> related lattice element fields. The magnetic multipole components used for tracking by <code>AT</code>, for example <code>PolynomB</code> are calculated by
<a href="#SCupdateMagnets">SCupdateMagnets</a> considering current setpoints <code>SetPointB</code>, calibration
errors <code>CalErrorB</code> and field offsets <code>PolynomBOffset</code> according to</p>
</div>
<div class="paragraph">
<p><code>PolynomB</code> = (1 + <code>CalErrorB</code>) .* <code>SetPointB</code> + <code>PolynomBOffset</code>.</p>
</div>
<div class="paragraph">
<p>The field offset may include a bending angle error of a pure
dipole magnet or can be used to specify static (higher order) <a href="#err:mult">multipole errors</a>, see below.</p>
</div>
<div class="paragraph">
<p>If the considered magnet is registered as a combined function magnet, the
actual bending angle is considered to depend on the quadrupole set point.
In order to capture that effect, the proper horizontal dipole field is added
which results from a quadrupole set point variation from the design value.
It is thereby assured that the coordinate system remains unchanged by a
rotation of dipole magnets.</p>
</div>
<div class="paragraph">
<p>See also <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCupdateMagnets">SCupdateMagnets</a>, <a href="#SCregisterMagnets">SCregisterMagnets</a> and <a href="#SCregisterSupport">SCregisterSupport</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="err:mult">Higher order multipoles</h3>
<div class="paragraph">
<p>Higher order multipole errors can be assigned in two different ways; static or dynamically updated. Dynamically updated multipoles are typically attributed to systematic multipoles.</p>
</div>
<div class="paragraph">
<p>Systematic multipole tables must be in AT&#8217;s PolynomA/B units and normalized to the considered component. For example, a <code>[Nx2]</code> table <code>AB_HCM</code> containing the multipoles induced by the excitation of a horizontal dipole corrector coil must have 1.0 at index <code>AB_HCM(1,2)</code>, for a table with systematic multipoles corresponding to a skew quadrupole corrector it would be <code>AB_SQ(2,1)=1</code>.</p>
</div>
<div class="paragraph">
<p>Multipole error tables can be read by <a href="#SCmultipolesRead">SCmultipolesRead</a> from a file and set by <a href="#SCsetMultipoles">SCsetMultipoles</a> to the lattice structure. After setting the systematic multipoles with <a href="#SCsetMultipoles">SCsetMultipoles</a> the corresponding lattice element may include the fields</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SysPolAFromA:
{[1 x N1], [1 x N2], &#8230;&#8203; [1 x Nn]} cell array containing normalized systematic PolynomA multipole errors from PolynomA entrys</p>
</li>
<li>
<p>SysPolAFromB:
{[1 x N1], [1 x N2], &#8230;&#8203; [1 x Nn]} cell array containing normalized systematic PolynomA multipole errors from PolynomB entrys</p>
</li>
<li>
<p>SysPolBFromA:
{[1 x N1], [1 x N2], &#8230;&#8203; [1 x Nn]} cell array containing normalized systematic PolynomB multipole errors from PolynomA entrys</p>
</li>
<li>
<p>SysPolBFromB:
{[1 x N1], [1 x N2], &#8230;&#8203; [1 x Nn]} cell array containing normalized systematic PolynomB multipole errors from PolynomB entrys</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the example above with a HCM and a skew quadrupole corrector coil the fields would like like the follwoing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SysPolAFromB = {AB_HCM(:,1)}</p>
</li>
<li>
<p>SysPolBFromB = {AB_HCM(:,2)}</p>
</li>
<li>
<p>SysPolAFromA = {[], AB_SQ(:,1)}</p>
</li>
<li>
<p>SysPolBFromA = {[], AB_SQ(:,2)}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that each array of multipoles may have a different length and that <a href="#SCsetMultipoles">SCsetMultipoles</a> sets the corresponding primary component to zero so that it does not get added later on. Each time the magnet fields are updated via <a href="#SCupdateMagnets">SCupdateMagnets</a>, the systematic multipoles are scaled by the current magnet excitation. In this example the normal and skew multipole components related to the skew quadrupole excitation are calcualted as</p>
</div>
<div class="paragraph">
<p>polA_SQ(i) = [(1 + <code>CalErrorA(2)</code>) .* <code>SetPointA(2)</code>] * <code>SysPolAFromA{2}(i)</code>,</p>
</div>
<div class="paragraph">
<p>polB_SQ(i) = [(1 + <code>CalErrorA(2)</code>) .* <code>SetPointA(2)</code>] * <code>SysPolBFromA{2}(i)</code>,</p>
</div>
<div class="paragraph">
<p>and the normal and skew multipoles associated with the horizontal dipole excitation goes as</p>
</div>
<div class="paragraph">
<p>polA_HCM(i) = [(1 + <code>CalErrorB(1)</code>) .* <code>SetPointB(1)</code>] * <code>SysPolAFromB{1}(i)</code>,</p>
</div>
<div class="paragraph">
<p>polB_HCM(i) = [(1 + <code>CalErrorB(1)</code>) .* <code>SetPointB(1)</code>] * <code>SysPolBFromB{1}(i)</code>.</p>
</div>
<div class="paragraph">
<p>All systematic multipoles are calculated analogously, summed up and added to the primary coil field excitations.</p>
</div>
<div class="paragraph">
<p>Additionally random multipole errors can be assigned via <a href="#SCsetMultipoles">SCsetMultipoles</a>. Here each multipole table entry gets scaled with a 2-sigma truncated Gaussian random number and stored in the lattice element field <code>PolynomBOffset</code> and <code>PolynomBOffset</code>. It is hereby assumed that the random multipole errors are static and not affected by the setpoints of the magnets.</p>
</div>
<div class="paragraph">
<p>See also <a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCupdateMagnets">SCupdateMagnets</a> and <a href="#SCsetMultipoles">SCsetMultipoles</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="err:inj">Injected beam</h3>
<div class="paragraph">
<p>The injected beam errors include a random shot-to-shot variation as
well as a static offset from the 6D design injection-trajectory. All errors regarding the injection pattern are centrally stored in the <code>SC.INJ</code> structure and include the fields</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Z0:
[6 x 1] array defining the current injection vector.</p>
</li>
<li>
<p>beamSize:
[6 x 6] array defining the beam sigma matrix.</p>
</li>
<li>
<p>randomInjectionZ:
[6 x 1] array defining the shot-to-shot injection jitter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each time a bunch is generated by <a href="#SCgenBunches">SCgenBunches</a>, the random injection error is calculated and added to the mean injected beam trajectory. If the number of particles per bunch is larger than one, individual particle launch conditions are randomly distributed around the bunch centroid using the beam sigma matrix with 3 <code>sigma</code>-truncated Gaussian distribution.  Otherwise the single macro-particle per bunch is launched at the bunch centroid trajectory.</p>
</div>
<div class="paragraph">
<p>See also <a href="#SCapplyErrors">SCapplyErrors</a></p>
</div>
</div>
<div class="sect2">
<h3 id="err:support">Support and Alignment</h3>
<div class="paragraph">
<p>The transverse misalignment model was developed to reflect the magnet support
structure of the ALS-U facility and includes the concepts of girders, plinths, and sections as
illustrated in <a href="#img-support">Figure 2</a>. Support structure elements can be registered using <a href="#SCregisterSupport">SCregisterSupport</a>.
Girders may have offset and roll errors, while sections and plinths (the
concrete slabs on which girders are mounted) are currently considered to have
offset errors only.</p>
</div>
<div class="paragraph">
<p>By default it is assumed that the magnets and BPMs are mounted on girders (if registered). The offset and roll errors of <a href="#err:BPMs">BPMs</a> and <a href="#err:magnets">magnets</a> are calculated by <a href="#SCupdateSupport">SCupdateSupport</a> as a sum of their individual misalignment and the misalignment of the girder at the element location. This feature can be switched off in <a href="#SCupdateSupport">SCupdateSupport</a> so that only random misalignment of the elements are considered. The actual misalignment distribution can be plotted using <a href="#SCplotSupport">SCplotSupport</a>.</p>
</div>
<div class="paragraph">
<p>Note that in order to apply any support structure misalignments, girders must be registered.</p>
</div>
<div id="img-support" class="imageblock text-center">
<div class="content">
<img src="../fig_supportModel.jpg" alt="fig supportModel" width="700">
</div>
<div class="title">Figure 2. Illustration of different possible support structure implementations (see <a href="#SCregisterSupport">SCregisterSupport</a> for more details and examples).</div>
</div>
<div class="paragraph">
<p>A global circumference error is modeled by <a href="#SCscaleCircumference">SCscaleCircumference</a> which scales all drift spaces such that the sections between two dipoles are scaled coherently.</p>
</div>
<div class="paragraph">
<p>It is worth noting that the ‘coordinate system’ of the BPMs may differ from AT’s reference system defined by the ideal lattice, as illustrated in <a href="#img-coordSystem">Figure 3</a>.</p>
</div>
<div id="img-coordSystem" class="imageblock text-center">
<div class="content">
<img src="../fig_coordinateSystem.jpg" alt="fig coordinateSystem" width="700">
</div>
<div class="title">Figure 3. Illustration of the toolkit coordinate system with misalignments.</div>
</div>
<div class="paragraph">
<p>If only small random magnet and BPM errors are considered as in <a href="#img-coordSystem">Figure 3 a)</a>, the particle trajectories and the BPM readings follow the design axis which is identical to the machine axis as defined by the magnet centers. In b) we assume a well corrected machine, e.g. one where the particles pass through the magnet centers which have offsets due to significant girder offsets. The BPMs in this example are distributed around the design axis. Both particle trajectories and BPM readings show large oscillations in AT’s coordinate system as the particles follow the magnets.</p>
</div>
<div class="paragraph">
<p>In the toolkit, however, it is by default assumed that BPMs are mounted on the girders, as indicated in c). While the particle trajectory oscilations remain, the calculated BPM readings in this case are distributed around AT’s design axis. In such a case using AT’s findorbit6() to calculate the closed orbit deviation would not necessarily reflect the machine state. Instead, the orbit deviation with respect to the magnet centers should be evaluated, see <a href="#SCgetCOD">SCgetCOD</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:example">SC Usage Example - FODO Lattice</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this example we present a complete simulated commissioning correction chain using a FODO lattice. The matlab script can be downloaded <a href="example.m">here</a>.</p>
</div>
<div class="sect2">
<h3 id="_setup_enviroment">Setup enviroment</h3>
<div class="paragraph">
<p>Clear workspace, initialize the global variable <code>plotFunctionFlag</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">clear all
global plotFunctionFlag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Set path to the AT function <code>atpath</code> and let AT set it&#8217;s paths. Also set the
path to the MML LOCO implementation and to the main SC folder which contains
e.g. the function <code>SCinit</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">addpath('~/at/atmat');
atpath()
addpath('~/MML/applications/loco/');
addpath('~/sc');</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_define_lattice_file">Define lattice file</h3>
<div class="paragraph">
<p>Define a simple FODO lattice and print the summary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">QF   = atquadrupole('QF',...
	0.5, 1.2,...
	'PassMethod','StrMPoleSymplectic4RadPass',...
	'Energy',2.5E9);
QD   = atquadrupole('QD',...
	0.5,-1.2,...
	'PassMethod','StrMPoleSymplectic4RadPass',...
	'Energy',2.5E9);
SF   = atsextupole('SF',...
	0.1, 6.0487,...
	'PassMethod','StrMPoleSymplectic4RadPass',...
	'Energy',2.5E9);
SD   = atsextupole('SD',...
	0.1,-9.5203,...
	'PassMethod','StrMPoleSymplectic4RadPass',...
	'Energy',2.5E9);
BEND = atsbend('BEND',...
	1,2*pi/40,...
	'PassMethod','BndMPoleSymplectic4Pass',...
	'Energy',2.5E9);
RFC  = atrfcavity('RFCav','Energy',2.5E9);
D2   = atdrift('Drift',0.25);
D3   = atdrift('Drift',0.2);
MARK = @(name) atmarker(name,'IdentityPass');

cell = [{D2};{MARK('SectionStart')};...
	{MARK('GirderStart')};{BEND};{D3};{SF};{D3};{MARK('GirderEnd')};...
	{MARK('GirderStart')};{MARK('BPM')};{QF};{D2};{D2};{BEND};{D3};{SD};...
	{D3};{QD};{D2};{MARK('BPM')};{MARK('GirderEnd')};{MARK('SectionEnd')}];

RING = [{RFC};repmat(cell,20,1)];
RING = atsetcavity(RING,20e5,1,50);

atsummary(RING);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_initialize_toolbox">Initialize toolbox</h3>
<div class="paragraph">
<p>Initialize the SC toolbox with the previously defined lattice cell structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC = SCinit(RING);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_register_lattice_in_sc">Register lattice in SC</h3>
<div class="paragraph">
<p>In the following section all relevant elements and error sources are
registered in SC.</p>
</div>
<div class="paragraph">
<p>Identify all BPMs in lattice structure and register them including
uncertainties of the calibration factor, offset, roll, turn-by-turn noise and
stored beam noise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = SCgetOrds(SC.RING,'BPM');
SC = SCregisterBPMs(SC,ords,...
	'CalError',5E-2 * [1 1],... % x and y, relative
	'Offset',500E-6 * [1 1],... % x and y, [m]
	'Noise',10E-6 * [1 1],...   % x and y, [m]
	'NoiseCO',1E-6 * [1 1],...  % x and y, [m]
	'Roll',1E-3);               % az, [rad]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identify the QFs in the lattice structure and register them as horizontal
corrector magnets with a limit of 1mrad and include uncertainties of the CM
calibration factor, quadrupole strength error, magnet offset and magnet roll.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = SCgetOrds(SC.RING,'QF');
SC = SCregisterMagnets(SC,ords,...
	'HCM',1E-3,...                      % [rad]
	'CalErrorB',[5E-2 1E-3],...         % relative
	'MagnetOffset',200E-6 * [1 1 0],... % x, y and z, [m]
	'MagnetRoll',200E-6* [1 0 0]);      % az, ax and ay, [rad]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identify the QDs in the lattice structure and register them as vertical
corrector magnets with a limit of 1mrad and include uncertainties of the CM
calibration factor , quadrupole strength error, magnet offset and magnet
roll.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = SCgetOrds(SC.RING,'QD');
SC = SCregisterMagnets(SC,ords,...
	'VCM',1E-3,...                      % [rad]
	'CalErrorA',[5E-2 0],...            % relative
	'CalErrorB',[0 1E-3],...            % relative
	'MagnetOffset',200E-6 * [1 1 0],... % x, y and z, [m]
	'MagnetRoll',200E-6* [1 0 0]);      % az, ax and ay, [rad]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identify the BENDs in the lattice structure and register them with a relative
bending angle error and magnet offset and magnet roll.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = SCgetOrds(SC.RING,'BEND');
SC = SCregisterMagnets(SC,ords,...
	'BendingAngle',1E-3,...             % relative
	'MagnetOffset',200E-6 * [1 1 0],... % x, y and z, [m]
	'MagnetRoll',200E-6* [1 0 0]);      % az, ax and ay, [rad]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identify the SF&amp;SD in the lattice structure and register them as skew
quadrupole corrector magnets with a K value limit of 0.1 and include
uncertainties of the skew quad calibration factor, sextupole strength error,
magnet offset and magnet roll.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = SCgetOrds(SC.RING,'SF|SD');
SC = SCregisterMagnets(SC,ords,...
	'SkewQuad',0.1,...                   % [1/m]
	'CalErrorA',[0 1E-3 0],...           % relative
	'CalErrorB',[0 0 1E-3],...           % relative
	'MagnetOffset',200E-6 * [1 1 0 ],... % x, y and z, [m]
	'MagnetRoll',200E-6* [1 0 0]);       % az, ax and ay, [rad]</code></pre>
</div>
</div>
<div class="paragraph">
<p>%Identify the cavity in the lattice structure and register it including
%uncertainties for the frequency [Hz], voltage [V] and phase offset [m]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = findcells(SC.RING,'Frequency');
SC = SCregisterCAVs(SC,ords,...
	'FrequencyOffset',5E3,... % [Hz]
	'VoltageOffset',5E3,...   % [V]
	'TimeLagOffset',0.5);     % [m]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identify girder start and end ordinates in lattice structure and register
them including uncertainties for the offset in x, y and z [m] and roll [rad]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = [SCgetOrds(SC.RING,'GirderStart');SCgetOrds(SC.RING,'GirderEnd')];
SC = SCregisterSupport(SC,...
	'Girder',ords,...
	'Offset',100E-6 * [1 1 0],... % x, y and z, [m]
	'Roll',200E-6* [1 0 0]);      % az, ax and ay, [rad]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identify section start and end ordinates in lattice structure and register
them including uncertainties for the offset in x, y and z [m]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">ords = [SCgetOrds(SC.RING,'SectionStart');SCgetOrds(SC.RING,'SectionEnd')];
SC = SCregisterSupport(SC,...
	'Section',ords,...
	'Offset',100E-6 * [1 1 0]); % x, y and z, [m]</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a last registration step we define the 6x6 beam sigma matrix, random
shot-to-shot injection variation and the uncertainty of the systematic
injection errors, both in 6D.  We furthermore define the relative
circumference uncertainty and the percentage of partcles which can be lost
while still getting a proper BPM reading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC.INJ.beamSize = diag([200E-6, 100E-6, 100E-6, 50E-6, 1E-3, 1E-4].^2);

SC.SIG.randomInjectionZ = [1E-4; 1E-5; 1E-4; 1E-5; 1E-4; 1E-4]; % [m; rad; m; rad; rel.; m]
SC.SIG.staticInjectionZ = [1E-3; 1E-4; 1E-3; 1E-4; 1E-3; 1E-3]; % [m; rad; m; rad; rel.; m]

SC.SIG.Circumference = 2E-4; % relative
SC.BPM.beamLostAt    = 0.6;  % relative</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_define_lattice_apertures">Define lattice apertures</h3>
<div class="paragraph">
<p>In this section a simple aperture model is defined. The aperture radius of
all drift spaces is 13mm, while an circular aperture is implemented in all
magnets with a radius of 10mm. In order to create a <code>pinhole</code>, the 50th
magnet is randomly choosen to get a small eliptical aperture.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">for ord=SCgetOrds(SC.RING,'Drift')
	SC.RING{ord}.EApertures = 13E-3 * [1 1]; % [m]
end

for ord=SCgetOrds(SC.RING,'QF|QD|BEND|SF|SD')
	SC.RING{ord}.EApertures = 10E-3 * [1 1]; % [m]
end

SC.RING{SC.ORD.Magnet(50)}.EApertures = [6E-3 3E-3]; % [m]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_check_registration">Check registration</h3>
<div class="paragraph">
<p>In this section the SC registration is checked for consistency and the
lattice is plotted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SCsanityCheck(SC);

SCplotLattice(SC,'nSectors',10);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apply_errors">Apply errors</h3>
<div class="paragraph">
<p>The next step is to generate and apply an error set based on the previolusly
defined uncertainties. The misalignments are plotted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC = SCapplyErrors(SC);

SCplotSupport(SC);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setup_correction_chain">Setup correction chain</h3>
<div class="paragraph">
<p>At this point the parameters of the correction chain may be defined. In this
example, we switch off the cavity and the sextupole magnets. Furthermore the
1 and 2-turn model trajectory response matrices are calcualted and a Tikhonov
regularization with a regularization parameter of <code>50</code> is used to calculate
the pseudo inverse of both matrices..</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC.RING = SCcronoff(SC.RING,'cavityoff');

sextOrds = SCgetOrds(SC.RING,'SF|SD');
SC = SCsetMags2SetPoints(SC,sextOrds,2,3,0,...
	'method','abs');

RM1 = SCgetModelRM(SC,SC.ORD.BPM,SC.ORD.CM,'nTurns',1);
RM2 = SCgetModelRM(SC,SC.ORD.BPM,SC.ORD.CM,'nTurns',2);

Minv1 = SCgetPinv(RM1,'alpha',50);
Minv2 = SCgetPinv(RM2,'alpha',50);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we define the number of particles per bunch, shots for averaging the
BPM reading and number of turns and ensure turn-by-turn tracking mode. The
noise level <code>eps</code> defines a stopping criteria for the feedback. Finally, we
switch on the global plot falg and plot uncorrected beam trajectory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC.INJ.nParticles = 1;
SC.INJ.nTurns     = 1;
SC.INJ.nShots     = 1;
SC.INJ.trackMode  = 'TBT';

eps   = 1E-4; % Noise level

plotFunctionFlag = 0;

SCgetBPMreading(SC);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_start_correction_chain">Start correction chain</h3>
<div class="paragraph">
<p>Run first turn feedback and apply correction if no error occured.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">[CUR,ERROR] = SCfeedbackFirstTurn(SC,Minv1,'verbose',1);
if ~ERROR; SC=CUR; else; return; end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Switch in 2-turn mode and get full 2-turn transmission by correcting the
first three BPMs of the second turn to the corresponding readings in the
first turn.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC.INJ.nTurns = 2;

[CUR,ERROR] = SCfeedbackStitch(SC,Minv2,...
	'nBPMs',3,...
	'maxsteps',20,...
	'verbose',1);
if ~ERROR; SC=CUR; else; return; end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run trajectory feedback on 2-turn readings. Then create a period 1
orbit by matching the second turn BPM readings to the first turn.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">[CUR,ERROR] = SCfeedbackRun(SC,Minv2,...
	'target',300E-6,...
	'maxsteps',30,...
	'eps',eps,...
	'verbose',1);
if ~ERROR; SC=CUR; else; return; end

[CUR,ERROR] = SCfeedbackBalance(SC,Minv2,...
	'maxsteps',32,...
	'eps',eps,...
	'verbose',1);
if ~ERROR; SC=CUR; else; return; end</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following loop the sextupole magnets are ramped up in 5 steps
and feedback is applied after each step.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">for S = linspace(0.1,1,5)

	SC = SCsetMags2SetPoints(SC,sextOrds,2,3,S,...
		'method','rel');

	[CUR,ERROR] = SCfeedbackBalance(SC,Minv2,...
		'maxsteps',10,...
		'eps',eps,...
		'verbose',1);

	if ~ERROR; SC=CUR; end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Switch off plotting every beam, switch the cavity on and plot initial
phase space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">plotFunctionFlag = 0;

SC.RING = SCcronoff(SC.RING,'cavityon');

SCplotPhaseSpace(SC,...
	'nParticles',10,...
	'nTurns',100);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following block performs an rf phase and frequency correction in
a loop and applies the corresponding correction step if no error
occured.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">for nIter=1:2
	% Perform RF phase correction.
	[deltaPhi,ERROR] = SCsynchPhaseCorrection(SC,...
		'nTurns',5,...      % Number of turns
		'nSteps',25,...     % Number of phase steps
		'plotResults',1,... % Final results are plotted
		'verbose',1);       % Print results
	if ERROR; error('Phase correction crashed');end

	% Apply phase correction
	SC = SCsetCavs2SetPoints(SC,SC.ORD.Cavity,...
			'TimeLag',deltaPhi,...
			'add');

	% Perform RF frequency correction.
	[deltaF,ERROR] = SCsynchEnergyCorrection(SC,...
		'range',40E3*[-1 1],... % Frequency range [kHz]
		'nTurns',20,...         % Number of turns
		'nSteps',15,...         % Number of frequency steps
		'plotResults',1,...     % Final results are plotted
		'verbose',1);           % Print results

	% Apply frequency correction
	if ~ERROR; SC = SCsetCavs2SetPoints(SC,SC.ORD.Cavity,...
			'Frequency',deltaF,...
			'add');
	else; return; end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Plot final phase space and check if beam capture is achieved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SCplotPhaseSpace(SC,'nParticles',10,'nTurns',1000);

[maxTurns,lostCount,ERROR] = SCgetBeamTransmission(SC,...
	'nParticles',100,...
	'nTurns',10,...
	'verbose',true);
if ERROR;return;end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beam capture achieved, switch to orbit mode for tracking. Calculate the orbit
response matrix and the dispersion. Assume a beam based alignment procedure
reduces the BPM offsets to 50um rms w.r.t. their neighbouring QF/QD magnets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">SC.INJ.trackMode = 'ORB';

MCO = SCgetModelRM(SC,SC.ORD.BPM,SC.ORD.CM,'trackMode','ORB');
eta = SCgetModelDispersion(SC,SC.ORD.BPM,SC.ORD.Cavity);

quadOrds = repmat(SCgetOrds(SC.RING,'QF|QD'),2,1);
BPMords  = repmat(SC.ORD.BPM,2,1);
SC       = SCpseudoBBA(SC,BPMords,quadOrds,50E-6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run orbit feedback in a loop with decreasing Tikhonov regularization
parameter <code>alpha</code> until no further improvment is achieved. Dispersion [m/Hz]
is included and scaled by a factor of 1E8 to get the same magnitude as the
orbit response [m/rad]
matrix.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">for	alpha = 10:-1:1
	% Get pseudo inverse
	MinvCO = SCgetPinv([MCO 1E8*eta],'alpha',alpha);

	% Run feedback
	[CUR,ERROR] = SCfeedbackRun(SC,MinvCO,...
		'target',0,...
		'maxsteps',50,...
		'scaleDisp',1E8,...
		'verbose',1);
	if ERROR;break;end

	% Calculate intial and final rms BPM reading.
	B0rms = sqrt(mean(SCgetBPMreading(SC ).^2,2));
	Brms  = sqrt(mean(SCgetBPMreading(CUR).^2,2));

	% Break if orbit feedback did not result in a smaller rms BPM reading
	if mean(B0rms)&lt;mean(Brms);break;end

	% Accept new machine
	SC = CUR;
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_perform_loco_based_linear_optics_correction">Perform LOCO based linear optics correction.</h3>
<div class="paragraph">
<p>The SC-LOCO interface is performed via a set of functions which are centrally
stored in a pseudo-library <code>SClocoLib</code>.
The first step is to setup the LOCO model
('setupLOCOmodel') from <code>SC</code>. Optional input
arguments are passed to <code>LocoFlags</code>.  In this example dispersion is included
in the evaluation and the horizontal and vertical weights are set to 100. The
next function ('getBPMCMstructure') sets up the BPM and CM data structures.
Again, optional arguments are passed to the corresponding structure, which
allows to fit the CM and BPM calibration errros. Next, the orbit response
matrix and the dispersion is measured ('getMeasurment')  using CM steps of
0.1mrad and an rf step of 1kHz, respectively. Finally the LOCO fit parameter
structure is setup via 'setupFitparameters'. We start with all <code>QF</code> and <code>QD</code>
quadrupoles which are individually powered and a strength variation of 1E-3
and 1E-4 is used to calculate the derivatives, respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">CMstep = 1E-4; % [rad]
RFstep = 1E3;  % [Hz]

[RINGdata,LOCOflags,Init] = SClocoLib('setupLOCOmodel',SC,...
	'Dispersion','Yes',...
	'HorizontalDispersionWeight',.1E2,...
	'VerticalDispersionWeight',.1E2);

[BPMData,CMData] =  SClocoLib('getBPMCMstructure',SC,CMstep,...
	{'BPM','FitGains','Yes'},...
	{'CM','FitKicks','Yes'});

LOCOmeasData =  SClocoLib('getMeasurement',SC,CMstep,RFstep,SC.ORD.BPM,SC.ORD.CM);

FitParameters = SClocoLib('setupFitparameters',SC,Init.SC.RING,RINGdata,RFstep,...
	{SCgetOrds(SC.RING,'QF'),'normal','individual',1E-3},... % {Ords, normal/skew, ind/fam, deltaK}
	{SCgetOrds(SC.RING,'QD'),'normal','individual',1E-4});   % {Ords, normal/skew, ind/fam, deltaK}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run LOCO fit procedure in a loop and apply the lattice correction after each
LOCO step, followed by an orbit correction step. After three iterations,
include coupling (off-diagonal response matrix blocks) and the skew
quadrupole correctors as LOCO fitparameters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">for n=1:6
	[~, BPMData, CMData, FitParameters, LOCOflags, RINGdata] = loco(LOCOmeasData,  BPMData,  CMData,  FitParameters,  LOCOflags,  RINGdata);

	SC = SClocoLib('applyLatticeCorrection',SC,FitParameters);

	SC = SClocoLib('applyOrbitCorrection',SC);

	SClocoLib('plotStatus',SC,Init,BPMData,CMData);

	if n==3
		LOCOflags.Coupling = 'Yes';

		FitParameters = SClocoLib('setupFitparameters',SC,Init.SC.RING,RINGdata,RFstep,...
			{SCgetOrds(SC.RING,'QF'),'normal','individual',1E-3},...
			{SCgetOrds(SC.RING,'QD'),'normal','individual',1E-4},...
			{SC.ORD.SkewQuad,'skew','individual',1E-3});
	end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:functions">Function Categories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following provides a list of functions implemented in <code>SC</code> sorted according to their primary purpose.</p>
</div>
<div class="sect2">
<h3 id="_initialization_2">Initialization</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCgetOrds">SCgetOrds</a></p>
</li>
<li>
<p><a href="#SCinit">SCinit</a></p>
</li>
<li>
<p><a href="#SCregisterBPMs">SCregisterBPMs</a></p>
</li>
<li>
<p><a href="#SCregisterCAVs">SCregisterCAVs</a></p>
</li>
<li>
<p><a href="#SCregisterMagnets">SCregisterMagnets</a></p>
</li>
<li>
<p><a href="#SCregisterSupport">SCregisterSupport</a></p>
</li>
<li>
<p><a href="#SCsanityCheck">SCsanityCheck</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tracking">Tracking</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCgenBunches">SCgenBunches</a></p>
</li>
<li>
<p><a href="#SCgetBPMreading">SCgetBPMreading</a></p>
</li>
<li>
<p><a href="#SCgetBeamTransmission">SCgetBeamTransmission</a></p>
</li>
<li>
<p><a href="#SCparticlesIn3D">SCparticlesIn3D</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_error_model">Error Model</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCapplyErrors">SCapplyErrors</a></p>
</li>
<li>
<p><a href="#SCgetSupportOffset">SCgetSupportOffset</a></p>
</li>
<li>
<p><a href="#SCgetTransformation">SCgetTransformation</a></p>
</li>
<li>
<p><a href="#SCmultipolesRead">SCmultipolesRead</a></p>
</li>
<li>
<p><a href="#SCrampUpErrors">SCrampUpErrors</a></p>
</li>
<li>
<p><a href="#SCrandnc">SCrandnc</a></p>
</li>
<li>
<p><a href="#SCscaleCircumference">SCscaleCircumference</a></p>
</li>
<li>
<p><a href="#SCsetMultipoles">SCsetMultipoles</a></p>
</li>
<li>
<p><a href="#SCupdateMagnets">SCupdateMagnets</a></p>
</li>
<li>
<p><a href="#SCupdateSupport">SCupdateSupport</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_visualization">Visualization</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCplotBPMreading">SCplotBPMreading</a></p>
</li>
<li>
<p><a href="#SCplotCMstrengths">SCplotCMstrengths</a></p>
</li>
<li>
<p><a href="#SCplotLattice">SCplotLattice</a></p>
</li>
<li>
<p><a href="#SCplotPhaseSpace">SCplotPhaseSpace</a></p>
</li>
<li>
<p><a href="#SCplotSupport">SCplotSupport</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_correction_scripts">Correction Scripts</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCfeedbackBalance">SCfeedbackBalance</a></p>
</li>
<li>
<p><a href="#SCfeedbackFirstTurn">SCfeedbackFirstTurn</a></p>
</li>
<li>
<p><a href="#SCfeedbackRun">SCfeedbackRun</a></p>
</li>
<li>
<p><a href="#SCfeedbackStitch">SCfeedbackStitch</a></p>
</li>
<li>
<p><a href="#SCfitInjectionZ">SCfitInjectionZ</a></p>
</li>
<li>
<p><a href="#SCgetPinv">SCgetPinv</a></p>
</li>
<li>
<p><a href="#SCpseudoBBA">SCpseudoBBA</a></p>
</li>
<li>
<p><a href="#SCsynchEnergyCorrection">SCsynchEnergyCorrection</a></p>
</li>
<li>
<p><a href="#SCsynchPhaseCorrection">SCsynchPhaseCorrection</a></p>
</li>
<li>
<p><a href="#SCtrajBBA">SCtrajBBA</a></p>
</li>
<li>
<p><a href="#SCtuneScan">SCtuneScan</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_lattice_properties">Lattice Properties</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCdynamicAperture">SCdynamicAperture</a></p>
</li>
<li>
<p><a href="#SCcalcTouschek">SCcalcTouschek</a></p>
</li>
<li>
<p><a href="#SCgetDispersion">SCgetDispersion</a></p>
</li>
<li>
<p><a href="#SCgetModelDispersion">SCgetModelDispersion</a></p>
</li>
<li>
<p><a href="#SCgetModelRING">SCgetModelRING</a></p>
</li>
<li>
<p><a href="#SCgetModelRM">SCgetModelRM</a></p>
</li>
<li>
<p><a href="#SCgetRespMat">SCgetRespMat</a></p>
</li>
<li>
<p><a href="#SCmomentumAperture">SCmomentumAperture</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_lattice_manipulation">Lattice Manipulation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#SCcronoff">SCcronoff</a></p>
</li>
<li>
<p><a href="#SCgetCMSetPoints">SCgetCMSetPoints</a></p>
</li>
<li>
<p><a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</li>
<li>
<p><a href="#SCsetCavs2SetPoints">SCsetCavs2SetPoints</a></p>
</li>
<li>
<p><a href="#SCsetMags2SetPoints">SCsetMags2SetPoints</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_function_list">Function List</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="SCBBA">SCBBA</h3>
<div class="sect3">
<h4 id="_name">NAME</h4>
<div class="paragraph">
<p>SCBBA - Performs model independent beam based alignment</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC, errorFlags] = SCBBA(SC, BPMords, magOrds, [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description">DESCRIPTION</h4>
<div class="paragraph">
<p>Perform a model independend beam based alignment procedure using either two-turn
trajectories or closed orbit bumps.
In two-turn mode, for each BPM the injected beam trajectory is varied within a
user defined range and the corresponding magnet is exercised on a user
defined vector of setpoints. If the initial trajectory variation causes beam
losses, the trajectory variation is reduced until all injected beam
trajectories reach the BBA-BPM. If the final trajectory variation at the
considered BBA-BPM is below a user defined threshold, a quadrupole may be
exercised to change the phase advance between the injection point and the
BPM (see option <code>'quadOrdPhaseAdvance'</code>).
In orbit mode an orbit bump is generated at each considerded BPM using orbit feedback
with weighting factors on a user defined window around the BBA BPM.
Finally, for each injected beam trajectory or orbit bump step the offset variation due
the change in magnet strength (see option <code>'magOrder'</code>) is recorded at the BPMs used
for measurement. A polynomial fit (see option <code>'fitOrder'</code>) is used to determine the
center of the BBA-BPM with respect to the used magnet.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>BPMords</code></dt>
<dd>
<p>[2 x n] array of BPM ordinates</p>
</dd>
<dt class="hdlist1"><code>magOrds</code></dt>
<dd>
<p>[2 x n] array of magnet ordinates for the corresponding BPMs in <code>BPMords</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure with updated BPM offsets</p>
</dd>
<dt class="hdlist1"><code>errorFlags</code></dt>
<dd>
<p>[2 x n] array of error flags for each BPM</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'mode'</code> (<code>SC.INJ.trackMode</code>)</dt>
<dd>
<p>Orbit or two-turn trajectory mode (<code>'TBT'</code>)</p>
</dd>
<dt class="hdlist1"><code>'outlierRejectionAt'</code> (<code>Inf</code>)</dt>
<dd>
<p>If the calculated BPM offset change is above the specified value, the measurement
is discarted and the BPM offset is not updated.</p>
</dd>
<dt class="hdlist1"><code>'fakeMeasForFailures'</code> (<code>1</code>)</dt>
<dd>
<p>This option intends to mimic the operater&#8217;s ability to identify errors in the
measurement procedure and adjust the fine tuning parameters for individual BPMs.
	 After performing the measurement routine, the rms value of the difference between
the BPM offsets and the magnet centers is calculated for both planes for all
successful BPMs. If this flag is set to <code>1</code>, all BPM offsets at which the measurement
failed are artificially generated using a Gaussian distribution with two sigma cutoff
with the rms value as described above.</p>
</dd>
<dt class="hdlist1"><code>'dipCompensation'</code> (<code>1</code>)</dt>
<dd>
<p>	 Flag specifying if dipole compensation at combined function magnets should be used in
measurement. This works only if the considered magnet is equipped with a registered HCM.
If so, the HCM is used to compensate the bending angle change when changing the main
quadrupole coil. If this option is switched off, the HCM is not used and the 'real'
quadrupole center is determined in the measurement and the BPM offset is adjusted in
order to account for the difference between the real quadrupole center and its design
value.</p>
</dd>
<dt class="hdlist1"><code>'nSteps'</code> (<code>10</code>)</dt>
<dd>
<p>Number of different trajectories/orbit bump steps for each magnet setting</p>
</dd>
<dt class="hdlist1"><code>'fitOrder'</code> (<code>1</code>)</dt>
<dd>
<p>Order of polynominal fitting, e.g. <code>1</code> for linear, <code>2</code> for quadratic fit.</p>
</dd>
<dt class="hdlist1"><code>'magOrder'</code> (<code>2</code>)</dt>
<dd>
<p>Order of magnet setpoint change, e.g. <code>2</code> for quadrupole, <code>3</code> for sextupole etc.</p>
</dd>
<dt class="hdlist1"><code>'magSPvec'</code> (<code>[0.95 1.05]</code>)</dt>
<dd>
<p>	 Strength variation of magnets. Can be either 1xN array of setpoint variations
(applied to all specified magnets) or cell array of 1xN arrays with
size(magSPvec)==size(magOrds) such that each magnet has it&#8217;s individual setpoint
variation array.</p>
</dd>
<dt class="hdlist1"><code>'magSPflag'</code> (<code>'rel'</code>)</dt>
<dd>
<p>	 Specify how magnet setpoint as specified by option 'magSPvec' should be changed,
e.g. relative or absolute (see <a href="#SCsetMags2SetPoints">SCsetMags2SetPoints</a>).</p>
</dd>
<dt class="hdlist1"><code>'skewQuadrupole'</code> (<code>0</code>)</dt>
<dd>
<p>	 If true, it is assumed that a skew quadrupole is used. Thus, the BPM readings in the
dimension other than the trajectory/orbit excitation is used for evaluation.</p>
</dd>
<dt class="hdlist1"><code>'switchOffSext'</code> (<code>0</code>)</dt>
<dd>
<p>	 Flag specifying if sextupole coil in BBA magnet should be switched off
(e.g. if quadrupole trim coils are used).</p>
</dd>
<dt class="hdlist1"><code>'RMstruct'</code> (<code>[]</code>)</dt>
<dd>
<p>	 Structure containing pre-calculated response matrix etc. for orbit feedback
(orbit mode only). If empty the relevant arrays are calculated with default
parameters.</p>
</dd>
<dt class="hdlist1"><code>'orbBumpWindow'</code> (<code>5</code>)</dt>
<dd>
<p>	 Number of BPMs adjacent to BBA BPM (upstream and downstream) where the BPM weighting
in orbit feedback is set to zero to allow for a pseudo orbit bump (orbit mode only).</p>
</dd>
<dt class="hdlist1"><code>'useBPMreadingsForOrbBumpRef'</code> (<code>0</code>)</dt>
<dd>
<p>	 If true the actual BPM readings will be used for the reference when generating the
pseudo orbit bump (orbit mode only) instead of zeros. (See github issue #22)</p>
</dd>
<dt class="hdlist1"><code>'BBABPMtarget'</code> (<code>1E-3</code>)</dt>
<dd>
<p>	 Desired offset variation at BBA-BPM (BPM adjacent to magnet) which should be
achieved by trajectory change or orbit bump.</p>
</dd>
<dt class="hdlist1"><code>'minBPMrangeAtBBABBPM'</code> (<code>0.5E-3</code>)</dt>
<dd>
<p>Threshold of change of offset at BBA-BPM; if below BBA evaluation is not performed.</p>
</dd>
<dt class="hdlist1"><code>'minBPMrangeDownstream'</code> (<code>100E-6</code>)</dt>
<dd>
<p>Minimum change of offset at downstream BPMs to be included in calculation.</p>
</dd>
<dt class="hdlist1"><code>'nXPointsNeededAtMeasBPM'</code> (<code>3</code>)</dt>
<dd>
<p>Number of x-positions at BBA-BPM required for linear regression at
measurement BPMs.</p>
</dd>
<dt class="hdlist1"><code>'maxNumOfDownstreamBPMs'</code> (<code>length(SC.ORD.BPM)</code>)</dt>
<dd>
<p>Number downstream BPMs considered in the data evaluation (2-turn mode only).</p>
</dd>
<dt class="hdlist1"><code>'minSlopeForFit'</code> (<code>0.03</code>)</dt>
<dd>
<p>	 Minimum fitted slope at measurement BPMs with respect to magnet change which
is still used in determining BPM center (a very small slope usually indicates
an unfortunate phase advance and can significantly affect the measurement if
not excluded). Only with linear fitting.</p>
</dd>
<dt class="hdlist1"><code>'maxStdForFittedCenters'</code> (<code>600E-6</code>)</dt>
<dd>
<p>If standard deviation of the fitted BPM centers as determined by all
downstream BPMs exceeds this value, output will be <code>'nan'</code>.</p>
</dd>
<dt class="hdlist1"><code>'maxTrajChangeAtInjection'</code> (<code>[0.9E-3 0.9E-3]</code>)</dt>
<dd>
<p>Maximum offset [m] and kick [rad] change at injection (2-turn mode only).</p>
</dd>
<dt class="hdlist1"><code>'quadOrdPhaseAdvance'</code> (<code>[]</code>)</dt>
<dd>
<p>	 Magnet ordinate which is used to change the phase advance between injection
and BBA-BPM (2-turn mode only).</p>
</dd>
<dt class="hdlist1"><code>'quadStrengthPhaseAdvance'</code> (<code>[0.95 1.05]</code>)</dt>
<dd>
<p>	 Relative magnet strength variation used to change the phase advance between
injection and BBA-BPM (2-turn mode only).</p>
</dd>
<dt class="hdlist1"><code>'plotLines'</code> (0)</dt>
<dd>
<p>If true, each injected beam and intermediate BBA results will be plotted.</p>
</dd>
<dt class="hdlist1"><code>'plotResults'</code> (0)</dt>
<dd>
<p>If true, final BBA results are plotted.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_error_flags">ERROR FLAGS</h4>
<div class="paragraph">
<p>The [2 x n] array of error flags specify if and why the measurement failed for each BPM
and may have the following value:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">(0)</dt>
<dd>
<p>All good</p>
</dd>
<dt class="hdlist1">(1)</dt>
<dd>
<p>Max. range at BBA-BPM to small (see option 'minBPMrangeAtBBABBPM')</p>
</dd>
<dt class="hdlist1">(2)</dt>
<dd>
<p>Max. range at downstream BPM to small (see option 'minBPMrangeOtherBPM')</p>
</dd>
<dt class="hdlist1">(3)</dt>
<dd>
<p>Fitted magnetic centers to far spread out (see option 'maxStdForFittedCenters')</p>
</dd>
<dt class="hdlist1">(4)</dt>
<dd>
<p>All downstream BPM measurements failed</p>
</dd>
<dt class="hdlist1">(5)</dt>
<dd>
<p>Unexpected error</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCsetMags2SetPoints">SCsetMags2SetPoints</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCfeedbackRun">SCfeedbackRun</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCapplyErrors">SCapplyErrors</h3>
<div class="sect3">
<h4 id="_name_2">NAME</h4>
<div class="paragraph">
<p>SCapplyErrors - Apply errors to lattice and diagnostic devices</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_2">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCapplyErrors(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_input">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The SC base structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_description_2">DESCRIPTION</h4>
<div class="paragraph">
<p>Applies errors to cavities, injection trajectory, BPMs, circumference,
support structures and magnets if the corresponding uncertanties defined in
<code>SC.SIG</code> are set. For example, for a magnet with ordinate <code>ord</code> every field
defined in <code>SC.SIG.Mag{ord}</code> will be used to generate a random number using a
Gaussian distribution with a cutoff (see option below) and <code>sigma</code> being the
value of the uncertainty field. The number will be stored in the
corresponding field of the lattice structure, thus <code>SC.RING{ord}</code>. An
exeption are bending angle errors which are stored in the <code>BendingAngleError</code>
field. See examples in the SCregister* functions for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_options_2">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nSig'</code> (2)</dt>
<dd>
<p>	Number of sigmas at which the Gaussian distribution of errors is truncated if not defined
explicitly for individual uncertainties.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The SC base structure with applied errors.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_2">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCregisterBPMs">SCregisterBPMs</a>, <a href="#SCregisterCAVs">SCregisterCAVs</a>, <a href="#SCrampUpErrors">SCrampUpErrors</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCcronoff">SCcronoff</h3>
<div class="sect3">
<h4 id="_name_3">NAME</h4>
<div class="paragraph">
<p>SCcronoff - switch cavity/radiation on/off</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_3">SYNOPSIS</h4>
<div class="paragraph">
<p><code>RING = SCcronoff(RING, mode, &#8230;&#8203;)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_3">DESCRIPTION</h4>
<div class="paragraph">
<p>Depending on <code>mode</code> SCcronoff switches the cavities / the radiation in <code>RING</code>
on or off. Possible <code>mode`s are &#8217;radiationoff'</code>, <code>'radiationon'</code>, <code>'cavityoff'</code>,
<code>'cavityon'</code>. Multiple modes can be specified.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_2">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>The modified base structure lattice.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples">EXAMPLES</h4>
<div class="paragraph">
<p>Switch cavities and radiation in <code>SC.RING</code> off.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC.RING = SCcronoff(SC.RING,'cavityoff','radiatonoff');</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCdynamicAperture">SCdynamicAperture</h3>
<div class="sect3">
<h4 id="_name_4">NAME</h4>
<div class="paragraph">
<p>SCdynamicAperture - calculates the dynamic aperture of a ring</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_4">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[DAs, RMAXs, thetas] = SCdynamicAperture(RING, dE [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_4">DESCRIPTION</h4>
<div class="paragraph">
<p>Calculates the dynamic aperture (i.e. the area of stable particle motion) of
<code>RING</code> at energy <code>dE</code>. The general strategy is to find the
maximum radii at which the particle motion is stable along a number of
straight lines, leaving the origin at angles <code>thetas</code>. The dynamic aperture
is then approximated as the area of the resulting polygon.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_2">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>Lattice cell structure.</p>
</dd>
<dt class="hdlist1"><code>dE</code></dt>
<dd>
<p>Momentum deviation.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_3">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'bounds'</code> (<code>[0,1e-3]</code>)</dt>
<dd>
<p>a 1x2 array containing a best guess for the upper and lower boundaries
of the maximum radius. These inital boundaries are automatically
refined in this routine, so a rough guess is good enough.</p>
</dd>
<dt class="hdlist1"><code>'nturns'</code> (1000)</dt>
<dd>
<p>number of turns used to determine whether a particle is stable.</p>
</dd>
<dt class="hdlist1"><code>'thetas'</code> (<code>linspace(0,2*pi,16)</code>)</dt>
<dd>
<p>angles at which the maximum radii are evaluated.</p>
</dd>
<dt class="hdlist1"><code>'accuracy'</code> (<code>1e-6</code>)</dt>
<dd>
<p>is the accuracy to which the dynamic aperture radii are determined [m].</p>
</dd>
<dt class="hdlist1"><code>'launchOnOrbit'</code> (0)</dt>
<dd>
<p>If true, particles are launched on closed orbit, otherwise on axis</p>
</dd>
<dt class="hdlist1"><code>'centerOnOrbit'</code> (1)</dt>
<dd>
<p>	If true, the closed orbit is subtracted from the DA coordinates, which
is advised for a corrected machine with support structure misalignments.</p>
</dd>
<dt class="hdlist1"><code>'useOrbit6'</code> (0)</dt>
<dd>
<p>If true, findorbit6 is used to determine the closed orbit, otherwise findorbit4</p>
</dd>
<dt class="hdlist1"><code>'auto'</code> (0)</dt>
<dd>
<p>if &gt;0, this number of automatically determined sampling points is used,
taking into account a presumed near-elliptical shape of the DA. In this
case <code>'thetas'</code> is ignored.</p>
</dd>
<dt class="hdlist1"><code>'plot'</code> (0)</dt>
<dd>
<p>if true, progress is plotted.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>if true, debug messages are printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_globals">GLOBALS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>runParallel</code></dt>
<dd>
<p>If true, a parfor loop is executed instead of a regular for loop.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_2">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>DA</code></dt>
<dd>
<p>Dynamic aperture in m^2.</p>
</dd>
<dt class="hdlist1"><code>RMAXs</code></dt>
<dd>
<p>Maximum radii at the evaluated <code>thetas</code>. <code>length(thetas)</code> array.</p>
</dd>
<dt class="hdlist1"><code>thetas</code></dt>
<dd>
<p>Angles at which the maximum radii were evaluated.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCfeedbackBalance">SCfeedbackBalance</h3>
<div class="sect3">
<h4 id="_name_5">NAME</h4>
<div class="paragraph">
<p>SCfeedbackBalance - balance two-turn BPM readings</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_5">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC, ERROR] = SCfeedbackBalance(SC, Mplus [,options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_5">DESCRIPTION</h4>
<div class="paragraph">
<p>Generates a period-1 closed orbit, after two-turn transmission has been
achieved. This is done by iteratively applying correction steps, calculated
based on the pseudo-inverse two-turn trajectory response matrix <code>Mplus</code>.  The
trajectory in the first turn is corrected towards the reference orbit <code>R0</code>,
whereas the trajectory in the second turn is corrected towards the trajectory
measured in the first turn; this approach seems to be more stable than the
directly application of the two-turn TRM to the two-turn BPM readings.
It converges to a state where BPM readings in both turns are very similar,
indicating a period-1 closed orbit.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_3">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>Mplus</code></dt>
<dd>
<p>Pseudo-inverse trajectory-response matrix.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_4">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'eps'</code> (<code>1e-5</code>)</dt>
<dd>
<p>break, if the coefficient of variation of the RMS BPM reading is below
this value</p>
</dd>
<dt class="hdlist1"><code>'R0'</code> (zeros)</dt>
<dd>
<p>target orbit in the format <code>[x_1 &#8230;&#8203; x_n y_1 &#8230;&#8203;y_n]</code>, where
<code>[x_i,y_i]</code> is the target position at the i-th BPM.</p>
</dd>
<dt class="hdlist1"><code>'maxsteps'</code> (10)</dt>
<dd>
<p>A maximum of <code>'maxsteps'</code> correction steps is performed.</p>
</dd>
<dt class="hdlist1"><code>'CMords'</code> (<code>SC.ORD.CM</code>)</dt>
<dd>
<p>List of CM ordinates to be used for correction</p>
</dd>
<dt class="hdlist1"><code>'BPMords'</code> (<code>SC.ORD.BPM</code>)</dt>
<dd>
<p>List of BPM ordinates at which the reading should be evaluated</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_3">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC-structure with corrected <code>SC.RING</code>.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>All fine.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>A correction step resulted in less transmission, than before.</p>
</dd>
<dt class="hdlist1"><code>2</code></dt>
<dd>
<p>Transmission was lost during correction procedure. This is an indicator
that <code>Mplus</code> might be unstable.</p>
</dd>
<dt class="hdlist1"><code>3</code></dt>
<dd>
<p>The feedback was unstable, when 'maxsteps' was reached.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_3">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetPinv">SCgetPinv</a>, <a href="#SCfeedbackRun">SCfeedbackRun</a>, <a href="#SCfeedbackFirstTurn">SCfeedbackFirstTurn</a>, <a href="#SCfeedbackStitch">SCfeedbackStitch</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCfeedbackFirstTurn">SCfeedbackFirstTurn</h3>
<div class="sect3">
<h4 id="_name_6">NAME</h4>
<div class="paragraph">
<p>SCfeedbackFirstTurn - achieves one-turn transmission</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_6">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC, ERROR] = SCfeedbackFirstTurn(SC, Mplus [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_6">DESCRIPTION</h4>
<div class="paragraph">
<p>Achieves a first turn in <code>SC.RING</code>.  This algorithm is based on the idea that
repeated orbit corrections calculated via a suitably regularized
pseudo-inverse trajectory-response matrix <code>Mplus</code> will drive the BPM readings
and CM settings to a fixed point.</p>
</div>
<div class="paragraph">
<p>lim      B_n = const. , with B    = Phi(Mplus . B ),     (1)
n&#8594;oo                      n+1                n</p>
</div>
<div class="paragraph">
<p>where mapping Phi maps corrector kicks to BPM-readings.
The RMS-values of both, BPM readings and CM settings, are determined by the
regularization of Mplus.  Successively - during the course of repeated
application of (1) - more and more transmission is achieved throughout the
ring, more magnets are traversed near their magnetic center (which is hopefully
at least somewhere near the BPM zero-point), resulting in decreased kicks.
If, however, the beam encounters a heavily displaced quadrupole magnet this
approach is bound to fail as correction towards the center of the last
reached BPM does no good, really. In this case the magnet has to be cleared
using other means than linear algebra.  In this approach the kicks of an
increasing number of the last reached CMs are deterministically ``wiggled''
until transmission to the next BPM is achieved. Then, application of (1) is
resumed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_4">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>Mplus</code></dt>
<dd>
<p>Pseudo-inverse trajectory-response matrix.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_5">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'maxsteps'</code> (<code>100</code>)</dt>
<dd>
<p>break, if this number of correction steps have been performed</p>
</dd>
<dt class="hdlist1"><code>'R0'</code> (zeros)</dt>
<dd>
<p>target orbit in the format <code>[x_1 &#8230;&#8203; x_n y_1 &#8230;&#8203;y_n]</code>, where
<code>[x_i,y_i]</code> is the target position at the i-th BPM.</p>
</dd>
<dt class="hdlist1"><code>'wiggleAfter'</code> (<code>20</code>)</dt>
<dd>
<p>Number of iterations without increased transmission to start wiggling.</p>
</dd>
<dt class="hdlist1"><code>'wiggleSteps'</code> (<code>64</code>)</dt>
<dd>
<p>Number of wiggle steps to perform, before incresing the number
of wiggling-CMs.</p>
</dd>
<dt class="hdlist1"><code>'wiggleRange'</code> (<code>[50E-6 200E-6]</code>)</dt>
<dd>
<p>Range ([min,max] in rad) within which to wiggle the CMs.</p>
</dd>
<dt class="hdlist1"><code>'CMords'</code> (<code>SC.ORD.CM</code>)</dt>
<dd>
<p>List of CM ordinates to be used for correction</p>
</dd>
<dt class="hdlist1"><code>'BPMords'</code> (<code>SC.ORD.BPM</code>)</dt>
<dd>
<p>List of BPM ordinates at which the reading should be evaluated</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_4">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC-structure with corrected <code>SC.RING</code>.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors_2">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>All fine.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>'maxsteps' was reached, without producing full transmission.</p>
</dd>
<dt class="hdlist1"><code>2</code></dt>
<dd>
<p>No BPM readings to beginn with.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_4">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetPinv">SCgetPinv</a>, <a href="#SCfeedbackRun">SCfeedbackRun</a>, <a href="#SCfeedbackStitch">SCfeedbackStitch</a>, <a href="#SCfeedbackBalance">SCfeedbackBalance</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCfeedbackRun">SCfeedbackRun</h3>
<div class="sect3">
<h4 id="_name_7">NAME</h4>
<div class="paragraph">
<p>SCfeedbackRun - iterative orbit correction</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_7">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC, ERROR] = SCfeedbackRun(SC, Mplus [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_7">DESCRIPTION</h4>
<div class="paragraph">
<p>Iteratively applies orbit corrections using the pseudoinverse of the
trajectory response matrix <code>Mplus</code>, until a break-condition specified by one
of the 'OPTIONS' is met.
The dispersion can be included, thus the rf frequency as a correction
parameter. If the dispersion is to be included, <code>Mplus</code> has to have the size
<code>(length(SC.ORD.CM{1}) + length(SC.ORD.CM{2}) + 1) x length(SC.ORD.BPM)</code>, otherwise the size
<code>(length(SC.ORD.CM{1}) + length(SC.ORD.CM{2})) x length(SC.ORD.BPM)</code>, or correspondingly if the CM
and/or BPM ordinates for the correction is explicitly given (see options below). <code>SC.RING</code> is
assumed to be a lattice with transmission through all considered turns. This routine will
also return, if transmission is lost.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_5">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>Mplus</code></dt>
<dd>
<p>Pseudo-inverse trajectory/orbit response matrix.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_6">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'target'</code> (<code>0</code>)</dt>
<dd>
<p>break, if the RMS BPM reading reaches this value</p>
</dd>
<dt class="hdlist1"><code>'maxsteps'</code> (<code>30</code>)</dt>
<dd>
<p>break, if this number of correction steps have been performed</p>
</dd>
<dt class="hdlist1"><code>'eps'</code> (<code>1e-5</code>)</dt>
<dd>
<p>break, if the coefficient of variation of the RMS BPM reading is below
this value</p>
</dd>
<dt class="hdlist1"><code>'R0'</code> (zeros(size(Mplus,2),1))</dt>
<dd>
<p>target orbit in the format <code>[x_1 &#8230;&#8203; x_n y_1 &#8230;&#8203;y_n]</code>, where
<code>[x_i,y_i]</code> is the target position at the i-th BPM.</p>
</dd>
<dt class="hdlist1"><code>'scaleDisp'</code> (0)</dt>
<dd>
<p>Scaling factor for and flag indicating if the dispersion is included in the response matrix</p>
</dd>
<dt class="hdlist1"><code>'CMords'</code> (<code>SC.ORD.CM</code>)</dt>
<dd>
<p>List of CM ordinates to be used for correction</p>
</dd>
<dt class="hdlist1"><code>'BPMords'</code> (<code>SC.ORD.BPM</code>)</dt>
<dd>
<p>List of BPM ordinates at which the reading should be evaluated</p>
</dd>
<dt class="hdlist1"><code>'weight'</code> (ones(size(Mplus,2),1))</dt>
<dd>
<p>weighting vector to be used in the CM step calculation in the format <code>[x_1 &#8230;&#8203; x_n y_1 &#8230;&#8203;y_n]</code>, where
<code>[x_i,y_i]</code> is the weight at the i-th BPM.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_5">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC-structure with corrected <code>SC.RING</code>.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors_3">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>All fine.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>The feedback was unstable, when 'maxsteps' was reached.</p>
</dd>
<dt class="hdlist1"><code>2</code></dt>
<dd>
<p>Transmission was lost during correction procedure. This is an indicator
that <code>Mplus</code> might be unstable.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_2">EXAMPLES</h4>
<div class="paragraph">
<p>Switch to orbit mode, get the model response matrix and dispersion. Calculate the psudo-inverse
while scaling the dispersion by 1E7 and using a Tikhonov regularization parameter of 10.
Finally, apply  and apply orbit feedback including dispersion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC.INJ.trackMode = 'ORB';
MCO = SCgetModelRM(SC,SC.ORD.BPM,SC.ORD.CM,'trackMode','ORB');
eta = SCgetModelDispersion(SC,SC.ORD.BPM,SC.ORD.Cavity);
MinvCO = SCgetPinv([MCO 1E7*eta],'alpha',10);
[CUR,ERROR] = SCfeedbackRun(SC,MinvCO,'scaleDisp',1E7);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_5">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetPinv">SCgetPinv</a>, <a href="#SCfeedbackStitch">SCfeedbackStitch</a>, <a href="#SCfeedbackFirstTurn">SCfeedbackFirstTurn</a>, <a href="#SCfeedbackBalance">SCfeedbackBalance</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCfeedbackStitch">SCfeedbackStitch</h3>
<div class="sect3">
<h4 id="_name_8">NAME</h4>
<div class="paragraph">
<p>SCfeedbackStitch - achieves 2-turn transmission</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_8">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC, ERROR] = SCfeedbackStitch(SC, Mplus [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_8">DESCRIPTION</h4>
<div class="paragraph">
<p>The purpose of this function is to go from 1-turn transmission to 2-turn
transmission. This is done by applying orbit correction based on the pseudo
inverse trajectory response matrix 'Mplus' applied to the first BPMs in
the 'SC.RING'. The reading of the BPMs in the second turn is corrected
towards the reading of these BPMs in the first turn. This approach has been
seen to be more stable than the direct application of the two-turn inverse
response matrix to the two-turn BPM data.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_6">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>Mplus</code></dt>
<dd>
<p>Pseudo-inverse trajectory-response matrix.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_7">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nBPMs'</code> (<code>4</code>)</dt>
<dd>
<p>number of BPMs which are used in the second turn</p>
</dd>
<dt class="hdlist1"><code>'maxsteps'</code> (<code>30</code>)</dt>
<dd>
<p>break, if this number of correction steps have been performed</p>
</dd>
<dt class="hdlist1"><code>'R0'</code> (zeros)</dt>
<dd>
<p>target orbit in the format <code>[x_1 &#8230;&#8203; x_n y_1 &#8230;&#8203;y_n]</code>, where
<code>[x_i,y_i]</code> is the target position at the i-th BPM.</p>
</dd>
<dt class="hdlist1"><code>'nRepro'</code> (3)</dt>
<dd>
<p>Number of consecutive beam injections for which the target should be reached</p>
</dd>
<dt class="hdlist1"><code>'CMords'</code> (<code>SC.ORD.CM</code>)</dt>
<dd>
<p>List of CM ordinates to be used for correction</p>
</dd>
<dt class="hdlist1"><code>'BPMords'</code> (<code>SC.ORD.BPM</code>)</dt>
<dd>
<p>List of BPM ordinates at which the reading should be evaluated</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_6">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC-structure with corrected <code>SC.RING</code>.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors_4">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>All fine.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p><code>maxsteps</code> was reached, without producing two-turn transmission.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_3">EXAMPLES</h4>
<div class="paragraph">
<p>Calculate the 2-turn response matrix and get the pseudo inverse using a Tikhonov regularization
parameter of 10. Switch the injection pattern to 2 turns and apply the stitching using the first
three BPMs, a maximum of 20 steps and print debug information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RM2 = SCgetModelRM(SC,SC.ORD.BPM,SC.ORD.CM,'nTurns',2);
Minv2 = SCgetPinv(RM2,'alpha',10);
SC.INJ.nTurns = 2;
[CUR,ERROR] = SCfeedbackStitch( SC,Minv2,'nBPMs',3,'maxsteps',20,'verbose',1);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_6">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetPinv">SCgetPinv</a>, <a href="#SCgetModelRM">SCgetModelRM</a>, <a href="#SCfeedbackRun">SCfeedbackRun</a>, <a href="#SCfeedbackFirstTurn">SCfeedbackFirstTurn</a>, <a href="#SCfeedbackBalance">SCfeedbackBalance</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCfitInjectionZ">SCfitInjectionZ</h3>
<div class="sect3">
<h4 id="_name_9">NAME</h4>
<div class="paragraph">
<p>SCfitInjectionZ - Fits the injected beam trajectory</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_9">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[deltaZ0, ERROR] = SCfitInjectionZ(SC, mode [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_9">DESCRIPTION</h4>
<div class="paragraph">
<p>This function calculates an transverse injection correction based on the BPM readings. Depending on the specified <code>mode</code>
different approaches are being used. In</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_2">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>mode</code></dt>
<dd>
<p>Method to identify the injection offset. Possible are</p>
</dd>
<dt class="hdlist1">- <code>'fitTrajectory'</code></dt>
<dd>
<p>Based on the ideal lattice a trajectory is fitted which best matches the first <code>N</code> BPM readings
as defined in the options.</p>
</dd>
<dt class="hdlist1">- <code>'injectionDrift'</code></dt>
<dd>
<p>It is assumed that a 1-turn period orbit is established (see <a href="#SCfeedbackBalance">SCfeedbackBalance</a>) and that
between the last BPM of the first turn and the first BPM in the second turn is a drift space.
A linear regression is used to identify the injected beam trajectory.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_8">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nDims'</code> (1:2)</dt>
<dd>
<p>Which transverse planes should be considered.</p>
</dd>
<dt class="hdlist1"><code>'nBPMs'</code> (1:3)</dt>
<dd>
<p>Which BPMs.</p>
</dd>
<dt class="hdlist1"><code>'plotFlag'</code> (0)</dt>
<dd>
<p>If true, results are plotted.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, additional information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_3">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>deltaZ0</code></dt>
<dd>
<p>Injected beam trajectory correction.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error flag.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgenBunches">SCgenBunches</h3>
<div class="sect3">
<h4 id="_name_10">NAME</h4>
<div class="paragraph">
<p>SCgenBunches - Generate injected beam particle coordinates.</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_10">SYNOPSIS</h4>
<div class="paragraph">
<p><code>Z = SCgenBunches(SC)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_10">DESCRIPTION</h4>
<div class="paragraph">
<p>Generates bunches according to the current injection setup as defined in
<code>SC.INJ</code>. The injection setup includes the fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>nParticles</code></dt>
<dd>
<p>Number of particles for tracking.</p>
</dd>
<dt class="hdlist1"><code>nTurns</code></dt>
<dd>
<p>Number of turns for tracking.</p>
</dd>
<dt class="hdlist1"><code>nShots</code></dt>
<dd>
<p>Number of injections used for averaging the BPM readings.</p>
</dd>
<dt class="hdlist1"><code>Z0ideal</code></dt>
<dd>
<p>[6 x 1] array defining the ideal injection vector.</p>
</dd>
<dt class="hdlist1"><code>Z0</code></dt>
<dd>
<p>[6 x 1] array defining the current injection vector.</p>
</dd>
<dt class="hdlist1"><code>beamSize</code></dt>
<dd>
<p>[6 x 6] array defining the beam sigma matrix.</p>
</dd>
<dt class="hdlist1"><code>randomInjectionZ</code></dt>
<dd>
<p>[6 x 1] array defining the shot-to-shot injection jitter.</p>
</dd>
<dt class="hdlist1"><code>trackMode</code></dt>
<dd>
<p>String defining the tracking mode.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For each bunch the random injection error is calculated and added to the mean
injected beam trajectory. If the number of particles per bunch is larger than
one, individual particle launch conditions are randomly distributed around
the bunch centroid using the beam sigma matrix.  Otherwise the single
macro-particle per bunch is launched at the bunch centroid trajectory. The
global injection count <code>SCinjections</code> is increased appropriately. If a
post-injection function is defined in <code>SC.INJ.postFun</code>, it is applied on the
generated particles.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_3">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_7">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Z</code></dt>
<dd>
<p>[6 x (#Bunches x #Shots x #Particles)] array of injected beam particle coordinates</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_7">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetBPMreading">SCgetBPMreading</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetBPMreading">SCgetBPMreading</h3>
<div class="sect3">
<h4 id="_name_11">NAME</h4>
<div class="paragraph">
<p>SCgetBPMreading - Calculates BPM readings based on the current injection scheme.</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_11">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[B, T] = SCgetBPMreading(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_11">DESCRIPTION</h4>
<div class="paragraph">
<p>This function calculates the particle trajectories based on the current
injection setup as defined in <code>SC.INJ</code> and calculates the corresponding BPM
readings. The injection setup is a structure with the fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>nParticles</code></dt>
<dd>
<p>Number of particles for tracking.</p>
</dd>
<dt class="hdlist1"><code>nTurns</code></dt>
<dd>
<p>Number of turns for tracking.</p>
</dd>
<dt class="hdlist1"><code>nShots</code></dt>
<dd>
<p>Number of injections used for averaging the BPM readings.</p>
</dd>
<dt class="hdlist1"><code>Z0ideal</code></dt>
<dd>
<p>[6 x 1] array defining the ideal injection vector.</p>
</dd>
<dt class="hdlist1"><code>Z0</code></dt>
<dd>
<p>[6 x 1] array defining the current injection vector.</p>
</dd>
<dt class="hdlist1"><code>beamSize</code></dt>
<dd>
<p>[6 x 6] array defining the beam sigma matrix.</p>
</dd>
<dt class="hdlist1"><code>randomInjectionZ</code></dt>
<dd>
<p>[6 x 1] array defining the shot-to-shot injection jitter.</p>
</dd>
<dt class="hdlist1"><code>trackMode</code></dt>
<dd>
<p>String defining the tracking mode. If set to orbit mode ('ORB'), the AT
function <code>findorbit6</code> is used to calculate the trajectories. Otherwise,
bunches are generated and tracking is performed.  In both cases the
corresponding BPM readings are calculated. If the tracking mode is
'pORB', the pseudo-orbit is calculated by averaging the turn-by-turn
BPM readings.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If the global variable <code>plotFunctionFlag</code> is 1, the tracking results are plotted.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_4">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_9">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'BPMords'</code> (<code>SC.ORD.BPM</code>)</dt>
<dd>
<p>List of BPM ordinates at which the reading should be returned</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_8">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>B</code></dt>
<dd>
<p>BPM readings</p>
</dd>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>Particle trajectories</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_globals_2">GLOBALS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>plotFunctionFlag</code></dt>
<dd>
<p>If true, each BPM reading is plotted</p>
</dd>
<dt class="hdlist1"><code>isExp</code></dt>
<dd>
<p>Specify if a real machine is being used, so that a custom user defined
function is being called instead</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_4">EXAMPLES</h4>
<div class="paragraph">
<p>Switch on plotting, track 100 particles for 2 turns and store the BPM readings in <code>B</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>global plotFunctionFlag
plotFunctionFlag  = 1;
SC.INJ.trackMode  = 'TBT';
SC.INJ.nParticles = 100;
SC.INJ.nTurns     = 2;
B = SCgetBPMreading(SC);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_8">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgenBunches">SCgenBunches</a>, <a href="#SCregisterBPMs">SCregisterBPMs</a>, <a href="#SCplotBPMreading">SCplotBPMreading</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetBeamTransmission">SCgetBeamTransmission</h3>
<div class="sect3">
<h4 id="_name_12">NAME</h4>
<div class="paragraph">
<p>SCgetBeamTransmission - Calculate turn-by-turn beam transmission</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_12">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[maxTurns, lostCount, ERROR] = SCgetBeamTransmission(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_12">DESCRIPTION</h4>
<div class="paragraph">
<p>Calculates the turn-by-turn beam transmission. A bunch is generated according
to the injection setting and tracking is performed. At each turn the relative
amount of lost particles is calculated. The number of survived turns is
determined by using the user specified field <code>SC.INJ.beamLostAt</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_options_10">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nParticles'</code> (<code>SC.INJ.nParticles</code>)</dt>
<dd>
<p>Number of particles.</p>
</dd>
<dt class="hdlist1"><code>'nTurns'</code> (<code>SC.INJ.nTurns</code>)</dt>
<dd>
<p>Number of turns.</p>
</dd>
<dt class="hdlist1"><code>'plotFlag'</code> (0)</dt>
<dd>
<p>If true, particle lost count is plotted.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, additional information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_4">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>maxTurns</code></dt>
<dd>
<p>Number of achieved turns.</p>
</dd>
<dt class="hdlist1"><code>lostCount</code></dt>
<dd>
<p>Turn-by-turn particle losses.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>False if beam survives all turns.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_9">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgenBunches">SCgenBunches</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetCMSetPoints">SCgetCMSetPoints</h3>
<div class="sect3">
<h4 id="_name_13">NAME</h4>
<div class="paragraph">
<p>SCgetCMSetPoints - Return current CM setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_13">SYNOPSIS</h4>
<div class="paragraph">
<p><code>setpoints = SCgetCMSetPoints(SC, CMords, nDim)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_13">DESCRIPTION</h4>
<div class="paragraph">
<p>Reads the setpoints of the CMs specified in <code>CMords</code> in the dimension <code>nDim</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_5">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>CMords</code></dt>
<dd>
<p>Array of CM ordinates in the lattice structure</p>
</dd>
<dt class="hdlist1"><code>nDim</code></dt>
<dd>
<p>Integer specifying CM dimension ([1|2] &#8594; [hor|ver])</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_9">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>setpoints</code></dt>
<dd>
<p>CM setpoints [rad]</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_10">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a>, <a href="#SCregisterMagnets">SCregisterMagnets</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetCOD">SCgetCOD</h3>
<div class="sect3">
<h4 id="_name_14">NAME</h4>
<div class="paragraph">
<p>SCgetCOD - Calculates closed orbit deviations with respect to magnet centers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_14">SYNOPSIS</h4>
<div class="paragraph">
<p><code>COD = SCgetCOD(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_14">DESCRIPTION</h4>
<div class="paragraph">
<p>This function calculates the closed orbit deviation from the magnetic centers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_6">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_11">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'ords'</code> (<code>SC.ORD.Magnet</code>)</dt>
<dd>
<p>List of magnet ordinates at which the orbit deviation should be evaluated.</p>
</dd>
<dt class="hdlist1"><code>'plot'</code> (<code>0</code>)</dt>
<dd>
<p>Flag indicating if closed orbit deviation should be plotted.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_10">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>COD</code></dt>
<dd>
<p>Orbit deviation w.r.t. magnet centers</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_5">EXAMPLES</h4>
<div class="paragraph">
<p>Calculate closed orbit deviation in magnets named 'SF' and 'SD' and plot results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>COD = SCgetCOD(SC,'ords',SCgetOrds(SC.RING,'SF|SD'),'plot',1);</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetDispersion">SCgetDispersion</h3>
<div class="sect3">
<h4 id="_name_15">NAME</h4>
<div class="paragraph">
<p>SCgetDispersion - Measure dispersion by changing the rf frequency of the cavities</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_15">SYNOPSIS</h4>
<div class="paragraph">
<p><code>eta = SCgetDispersion(SC, RFstep)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_15">DESCRIPTION</h4>
<div class="paragraph">
<p>Calculates reference BPM reading, then changes the rf frequency and gets a
second BPM reading in order to calculate the dispersion.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_7">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>RFstep</code></dt>
<dd>
<p>Change of RF frequency in Hz</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_12">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'BPMords'</code> (<code>SC.ORD.BPM</code>)</dt>
<dd>
<p>List of BPM ordinates at which the dispersion should be returned</p>
</dd>
<dt class="hdlist1"><code>'CAVords'</code> (<code>SC.ORD.CAV</code>)</dt>
<dd>
<p>List of cavity ordinates with which the dispersion should be measured</p>
</dd>
<dt class="hdlist1"><code>'nSteps'</code> (2)</dt>
<dd>
<p>Number of RF steps (1st RF step is considered the reference). If more than 2 steps are
specified, the measurement is bi-directional</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_5">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>eta</code></dt>
<dd>
<p>Dispersion [m/Hz]</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_6">EXAMPLES</h4>
<div class="paragraph">
<p>Calculate the dispersion with a 1 kHz rf frequency change.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>eta = SCgetDispersion(SC,1E3);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_11">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCsetCavs2SetPoints">SCsetCavs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetModelDispersion">SCgetModelDispersion</h3>
<div class="sect3">
<h4 id="_name_16">NAME</h4>
<div class="paragraph">
<p>SCgetModelDispersion - Calculates the lattice dispersion based on current setpints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_16">SYNOPSIS</h4>
<div class="paragraph">
<p><code>eta = SCgetModelDispersion(SC,BPMords,CAVords [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_16">DESCRIPTION</h4>
<div class="paragraph">
<p>Calcualtes the dispersion at the ordinates <code>BPMords</code> by changing the frequency of the rf cavities
specified in <code>CAVords</code> using the current magnet setpoints without any roll/alignment/calibration
errors. Optionally the design lattice is used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_11">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>eta</code></dt>
<dd>
<p>The dispersion given in [m/Hz].</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_13">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'rfStep'</code> (1E3)</dt>
<dd>
<p>Change of rf frequency [Hz]</p>
</dd>
<dt class="hdlist1"><code>'useIdealRing'</code> (0)</dt>
<dd>
<p>If true, the design lattice specified in <code>SC.IDEALRING</code> is used.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_12">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetDispersion">SCgetDispersion</a>, <a href="#SCgetModelRM">SCgetModelRM</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetModelRING">SCgetModelRING</h3>
<div class="sect3">
<h4 id="_name_17">NAME</h4>
<div class="paragraph">
<p>SCgetModelRING - Returns a model lattice based on current setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_17">SYNOPSIS</h4>
<div class="paragraph">
<p><code>RING = SCgetModelRING(SC, [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_17">DESCRIPTION</h4>
<div class="paragraph">
<p>This function calculates a model lattice based on the setpoints of <code>SC.RING</code>. Misalignments,
lattice errors and dipole fields are excluded.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_12">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>The idealised RING structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_14">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'includeAperture'</code> (<code>0</code>)</dt>
<dd>
<p>If true, the returned model ring includes the aperture</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetModelRM">SCgetModelRM</h3>
<div class="sect3">
<h4 id="_name_18">NAME</h4>
<div class="paragraph">
<p>SCgetModelRM - determine the lattice response matrix based on current setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_18">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[RM, RING] = SCgetModelRM(SC,BPMords,CMords [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_18">DESCRIPTION</h4>
<div class="paragraph">
<p>SCgetModelRM calculates the reponse matrix <code>RM</code> with the BPMs at the ordinates <code>BPMords</code>
and corrector magnets at ordinates <code>CMords</code> using the current magnet setpoints without any
roll/alignment/calibration errors. <code>CMords</code> is a 2-cell array containing the two lists for the
horizontal and vertical CMs respectively.
This routine can determine the turn-by-turn RM, as well as the orbit-RM; see
option 'trackMode'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_13">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RM</code></dt>
<dd>
<p>The response matrix given in [m/rad].</p>
</dd>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>The idealised RING structure, which was used to determine the RM.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_15">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'trackMode'</code> (<code>'TBT'</code>)</dt>
<dd>
<p>If <code>TBT</code> the turn-by-turn RM is calculated. If <code>ORB</code> the orbit RM is calculated, using <code>findorbit6</code></p>
</dd>
<dt class="hdlist1"><code>'Z0'</code> (<code>zeros(6,1)</code>)</dt>
<dd>
<p>Initial condition for tracking. In <code>ORB</code>-mode this is used as the initial guess for <code>findorbit6</code>.</p>
</dd>
<dt class="hdlist1"><code>'nTurns'</code> (<code>1</code>)</dt>
<dd>
<p>Number of turns over which to determine the TBT-RM. Ignored if in <code>ORB</code>-mode.</p>
</dd>
<dt class="hdlist1"><code>'dkick'</code> (<code>1e-5</code>)</dt>
<dd>
<p>Kick [rad] to be added when numerically determining the partial derivatives.</p>
</dd>
<dt class="hdlist1"><code>'useIdealRing'</code> (<code>0</code>)</dt>
<dd>
<p>If true, the design lattice specified in <code>SC.IDEALRING</code> is used.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetOrds">SCgetOrds</h3>
<div class="sect3">
<h4 id="_name_19">NAME</h4>
<div class="paragraph">
<p>SCgetOrds - get ordinates of elements from FamName</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_19">SYNOPSIS</h4>
<div class="paragraph">
<p><code>ords = SCgetOrds(RING, rx [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_19">DESCRIPTION</h4>
<div class="paragraph">
<p>SCgetOrds produces the ordinates (indices) of elements in <code>RING</code> whose
<code>FamName</code> matches the regular expression(s) <code>rx</code>.  <code>rx</code> can be a single regex
or a cell-array containing multiple regexes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_6">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ords</code></dt>
<dd>
<p>If <code>rx</code> is a single string <code>ords</code> is a single array; if <code>rx</code> is a
cell-array <code>ords</code> is a cell-array containing the respective ordinates.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_16">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true additional information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_7">EXAMPLES</h4>
<div class="paragraph">
<p>Find all lattice elements in <code>SC.RING</code> beginning with <code>QF</code> and <code>QD</code> and return
them in a single array <code>ords</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'^QF|^QD');</pre>
</div>
</div>
<div class="paragraph">
<p>Find all lattice elements in <code>SC.RING</code> named <code>QF</code> and <code>QD</code> and return
each of them in a cell array <code>ords</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,{'^QF$','^QD$'});</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetPinv">SCgetPinv</h3>
<div class="sect3">
<h4 id="_name_20">NAME</h4>
<div class="paragraph">
<p>SCgetPinv - Calculates the pseudo inverse of a matrix</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_20">SYNOPSIS</h4>
<div class="paragraph">
<p><code>Minv = SCgetPinv(M [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_20">DESCRIPTION</h4>
<div class="paragraph">
<p>Calculats the pseudo-inverse <code>Minv</code> of the input matrix <code>M</code> based on a singular value
decomposition. Optional parameters define the number of singular values to be set to zero, a
global scaling factor applied to all singular values or the Tikhonov regularization parameter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_8">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>M</code></dt>
<dd>
<p>Input matrix</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_17">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'N'</code> (0)</dt>
<dd>
<p>Number of singular values to be set to zero (starting from smallest value)</p>
</dd>
<dt class="hdlist1"><code>'damping'</code> ([])</dt>
<dd>
<p>If not empty, all singular values are scaled by this factor</p>
</dd>
<dt class="hdlist1"><code>'alpha'</code> ([])</dt>
<dd>
<p>If not empty, Tikhonov regularization is applied with regularization parameter <code>alpha</code></p>
</dd>
<dt class="hdlist1"><code>'plot'</code> (0)</dt>
<dd>
<p>If true, initial and inverse singular value spectrum is plotted</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_7">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Minv</code></dt>
<dd>
<p>Pseudo-inverse of the input matrix.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_8">EXAMPLES</h4>
<div class="paragraph">
<p>Calculates the svd-based pseudo-inverse</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Minv = SCgetPinv(M);</pre>
</div>
</div>
<div class="paragraph">
<p>Calculates the svd-based pseudo-inverse while cutting off the last 10 singular values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Minv = SCgetPinv(M,'N',10);</pre>
</div>
</div>
<div class="paragraph">
<p>Calculates the svd-based pseudo-inverse while cutting off the last 10 singular values and using a
Tikhonov regularization with regularization parameter of 10.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Minv = SCgetPinv(M,'N',10,'alpha',1);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_13">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetModelRM">SCgetModelRM</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetRespMat">SCgetRespMat</h3>
<div class="sect3">
<h4 id="_name_21">NAME</h4>
<div class="paragraph">
<p>SCgetRespMat - Simulates the response matrix measurement</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_21">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[M, Err, Cmsteps] = SCgetRespMat(SC, Amp, BPMords, CMords [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_21">DESCRIPTION</h4>
<div class="paragraph">
<p>Gets the beam based response matrix based on the current injection pattern and using the BPMs and
CMs specified in <code>BPMords</code> and <code>CMords</code>, respectively. By default the response matrix is measured
using a fixed initial kick amplitude <code>Amp</code> (see options below), which can be given either as a
single value for all CMs or as a cell array with amplitudes for each CM specified in <code>CMords</code>.</p>
</div>
<div class="paragraph">
<p>If the applied CM setpoint was clipped because of CM limits, the measurement is repeated with the
different direction, thus <code>-Amp</code>. If the beam transmission for any applied CM step is less then
for the reference measurement, the CM step is scaled to 90% and the measurument is repeated.</p>
</div>
<div class="paragraph">
<p>Additionally, the measurement mode can be specified as <code>fixedOffset</code>. In this case <code>Amp</code> specifies
the maximum BPM offset difference which should be achieved for each CM step. The CM step is
iterated three times for every CM to reach the desired change of BPM readings.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_9">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>Amp</code></dt>
<dd>
<p>	Amplitude of response matrix measurement step [m or rad], either single value or cell array
defining the amplitude for every CM specified in <code>CMords</code></p>
</dd>
<dt class="hdlist1"><code>BPMords</code></dt>
<dd>
<p>List of BPM ordinates at which the reading should be returned</p>
</dd>
<dt class="hdlist1"><code>CMords</code></dt>
<dd>
<p>List of CM ordinates at which the reading should be returned</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_18">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'mode'</code> (<code>'fixedKick'</code>)</dt>
<dd>
<p>Measurement mode, either <code>'fixedKick'</code> or <code>'fixedOffset'</code></p>
</dd>
<dt class="hdlist1"><code>'nSteps'</code> (2)</dt>
<dd>
<p>Number of CM steps (1st CM step is considered the reference). If more than 2 steps are
specified, the measurement is bi-directional</p>
</dd>
<dt class="hdlist1"><code>'fit'</code> (<code>'linear'</code>)</dt>
<dd>
<p>Fit method, either <code>'linear'</code> or <code>'quadratic'</code></p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_14">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>M</code></dt>
<dd>
<p>Response matrix [m/rad]</p>
</dd>
<dt class="hdlist1"><code>Err</code></dt>
<dd>
<p>Chi squared errror of RM entries [m/rad]</p>
</dd>
<dt class="hdlist1"><code>CMsteps</code></dt>
<dd>
<p>Maximum CM steps used for RM measurement [rad]</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_14">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetModelRM">SCgetModelRM</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a>, <a href="#SCgetCMSetPoints">SCgetCMSetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetSupportOffset">SCgetSupportOffset</h3>
<div class="sect3">
<h4 id="_name_22">NAME</h4>
<div class="paragraph">
<p>SCgetSupportOffset - Calculates the combined support structure offset at a certain location</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_22">SYNOPSIS</h4>
<div class="paragraph">
<p><code>off = SCgetSupportOffset(SC, s)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_22">DESCRIPTION</h4>
<div class="paragraph">
<p>This function evaluates the total offset of the support structures that have
been defined via <a href="#SCregisterSupport">SCregisterSupport</a> at the longitudinal positions <code>s</code> by linearly interpolating
between support structure start- and endpoints (girder + sections + plinths, if registered).
Note that this calculation may not provide the proper values if magnets with non-zero bending
angle are within the support structure because it does not account for the rotation of the
local coordinate system along the beam trajectory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_10">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The <code>SC</code> core structure.</p>
</dd>
<dt class="hdlist1"><code>s</code></dt>
<dd>
<p>Array of s-positions at which the offset is evaluated.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_8">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>off</code></dt>
<dd>
<p><code>[3,length(s)]</code>-array containing the [dx/dy/dz] total support structure offsets at <code>s</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_15">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCupdateSupport">SCupdateSupport</a>, <a href="#SCgetSupportRoll">SCgetSupportRoll</a>, <a href="#SCplotSupport">SCplotSupport</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetSupportOffset_backup210212">SCgetSupportOffset</h3>
<div class="sect3">
<h4 id="_name_23">NAME</h4>
<div class="paragraph">
<p>SCgetSupportOffset - Calculates the combined support structure offset at a certain location</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_23">SYNOPSIS</h4>
<div class="paragraph">
<p><code>off = SCgetSupportOffset(SC, s)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_23">DESCRIPTION</h4>
<div class="paragraph">
<p>This function evaluates the total offset of the support structures that have
been defined via <a href="#SCregisterSupport">SCregisterSupport</a> at the longitudinal positions <code>s</code> by linearly interpolating
between support structure start- and endpoints (girder + sections + plinths, if registered).
Note that this calculation may not provide the proper values if magnets with non-zero bending
angle are within the support structure because it does not account for the rotation of the
local coordinate system along the beam trajectory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_11">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The <code>SC</code> core structure.</p>
</dd>
<dt class="hdlist1"><code>s</code></dt>
<dd>
<p>Array of s-positions at which the offset is evaluated.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_9">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>off</code></dt>
<dd>
<p><code>[3,length(s)]</code>-array containing the [dx/dy/dz] total support structure offsets at <code>s</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_16">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCupdateSupport">SCupdateSupport</a>, <a href="#SCgetSupportRoll">SCgetSupportRoll</a>, <a href="#SCplotSupport">SCplotSupport</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetSupportRoll">SCgetSupportRoll</h3>
<div class="sect3">
<h4 id="_name_24">NAME</h4>
<div class="paragraph">
<p>SCgetSupportRoll - Calculates the combined support structure roll, pitch and yaw angles at a certain location</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_24">SYNOPSIS</h4>
<div class="paragraph">
<p><code>roll = SCgetSupportRoll(SC, s)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_24">DESCRIPTION</h4>
<div class="paragraph">
<p>This function evaluates the total roll, pitch and yaw angles of the support structures that have
been defined via <a href="#SCregisterSupport">SCregisterSupport</a> at the longitudinal positions <code>s</code>.
The support structure pitch and yaw angles are calcualted from the horizontal and vertical offsets
of the start end endpoints of the corresponding top layer support structure
(the order is: girders&#8594;plinths&#8594;sections). The roll angle is a sum of the roll angles of all
underlying support structures.
Note that this calculation may not provide the proper values if magnets with non-zero bending
angle are within the support structure because it does not account for the rotation of the
local coordinate system along the beam trajectory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_12">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The <code>SC</code> core structure.</p>
</dd>
<dt class="hdlist1"><code>s</code></dt>
<dd>
<p>Array of s-positions at which the offset is evaluated.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_10">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>roll</code></dt>
<dd>
<p><code>[3,length(s)]</code>-array containing the [az/ax/ay] total support structure rolls at <code>s</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_17">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCupdateSupport">SCupdateSupport</a>, <a href="#SCgetSupportOffset">SCgetSupportOffset</a>, <a href="#SCplotSupport">SCplotSupport</a>, <a href="#SCapplyErrors">SCapplyErrors</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCgetTransformation">SCgetTransformation</h3>
<hr>
</div>
<div class="sect2">
<h3 id="SCinit">SCinit</h3>
<div class="sect3">
<h4 id="_name_25">NAME</h4>
<div class="paragraph">
<p>SCinit - Initializes the toolbox</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_25">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCinit(RING)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_25">DESCRIPTION</h4>
<div class="paragraph">
<p>This function is used to initialize the toolbox. Required input <code>RING</code> is an AT lattice cell structure,
which is also saved as the ideal lattice in <code>SC.IDEALRING</code>. The global variables <code>plotFunctionFlag</code>
and <code>SCinjections</code> are set to initial values.</p>
</div>
</div>
<div class="sect3">
<h4 id="_globals_3">GLOBALS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>plotFunctionFlag</code> ([])</dt>
<dd>
<p>	If not empty, every call of <a href="#SCgetBPMreading">SCgetBPMreading</a> calls <a href="#SCplotBPMreading">SCplotBPMreading</a>, hence plotting particle
trajectories and BPM readings.</p>
</dd>
<dt class="hdlist1"><code>SCinjections</code> (0)</dt>
<dd>
<p>Counts the number of injected beams. Gets increased by <a href="#SCgenBunches">SCgenBunches</a></p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_11">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>Base structure including the lattice structure.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SClocoLib">SClocoLib</h3>
<div class="sect3">
<h4 id="_name_26">NAME</h4>
<div class="paragraph">
<p>SClocoLib - Function library to use LOCO with SC</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_26">SYNOPSIS</h4>
<div class="paragraph">
<p><code>varargout = SClocoLib(funName, varargin])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_26">DESCRIPTION</h4>
<div class="paragraph">
<p><code>SClocoLib</code> is a function library intended to connect the workflows and data
structures of the AT/MML function <code>loco</code> with the <code>SC</code> workflow. The input
string <code>funName</code> defines the function which should be used. Additional input
arguments and the return values of <code>SClocoLib</code> differ, depending on the
called function. The following will describe each provided function in
detail:</p>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_27">NAME</h4>
<div class="paragraph">
<p>setupLOCOmodel - Sets up the LOCO model</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_27">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[RINGdata, LOCOflags, Init] = SClocoLib('setupLOCOmodel', SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_27">DESCRIPTION</h4>
<div class="paragraph">
<p>This function sets up the LOCO model used by the function <code>loco</code> based on the
<code>SC</code> structure.  Additionally lattice properties of <code>SC.RING</code> are calculated
by <a href="#SCcalcLatticeProperties">SCcalcLatticeProperties</a> and stored together with <code>SC</code> in the structure
<code>Init</code>. This is usefull for further LOCO steps.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_13">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_19">OPTIONS</h4>
<div class="paragraph">
<p>Additional arguments can be given as name-value pairs and are written as
fields in <code>LOCOflags</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_12">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RINGdata</code></dt>
<dd>
<p>RING data used by <code>locoresponsematrix</code>.</p>
</dd>
<dt class="hdlist1"><code>LOCOflags</code></dt>
<dd>
<p>LOCO flags used by <code>loco</code>.</p>
</dd>
<dt class="hdlist1"><code>Init</code></dt>
<dd>
<p>Structure containing the initial <code>SC</code> structure and (disturbed) lattice
properties.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_9">EXAMPLES</h4>
<div class="paragraph">
<p>Set up the LOCO model, include dispersion and set the horizontal and vertical
dispersion weights to 100.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[RINGdata,LOCOflags,Init] = SClocoLib('setupLOCOmodel',SC,...
	'Dispersion','Yes',...
	'HorizontalDispersionWeight',.1E2,...
	'VerticalDispersionWeight',.1E2);</pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_28">NAME</h4>
<div class="paragraph">
<p>getBPMCMstructure - Sets up the BPM and CM data structure for LOCO</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_28">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[BPMData, CMData] =  SClocoLib('getBPMCMstructure', SC, CMstep [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_28">DESCRIPTION</h4>
<div class="paragraph">
<p>This function sets up the BPM and CM data structure used by the function
<code>loco</code> based on the <code>SC</code> registration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_14">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>CMstep</code></dt>
<dd>
<p>CM step [rad] for <code>locoresponsematrix</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_20">OPTIONS</h4>
<div class="paragraph">
<p>Additional arguments can be given as cell arrays of strings as
type-name-value triples and are written as fields in in the BPM or CM structure
(see examples) or to specify the used BPMs and CMs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_13">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>BPMData</code></dt>
<dd>
<p>BPM data structure.</p>
</dd>
<dt class="hdlist1"><code>CMData</code></dt>
<dd>
<p>CM data structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_10">EXAMPLES</h4>
<div class="paragraph">
<p>Set up the BPM and CM data structures with a CM step of <code>0.1mrad</code> and include
fitting the BPM gains and CM kicks and use only every second CM and BPM in both planes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[BPMData,CMData] =  SClocoLib('getBPMCMstructure',SC,1E-4,...
	{'BPM','FitGains','Yes'},...
	{'CM','FitKicks','Yes'},...
{'CMords',SC.ORD.CM{1}(1:2:end),SC.ORD.CM{2}(1:2:end)},...
{'BPMords',SC.ORD.BPM(1:2:end),SC.ORD.BPM(1:2:end)};</pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_29">NAME</h4>
<div class="paragraph">
<p>getMeasurement - Simulates the response matrix measurement</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_29">SYNOPSIS</h4>
<div class="paragraph">
<p><code>LOCOmeasData =  SClocoLib('getMeasurement', SC, CMstep, RFstep [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_29">DESCRIPTION</h4>
<div class="paragraph">
<p>Sets up the 'measured' response matrix data structure used by <code>loco</code>. Optional arguments
are passed to <a href="#SCgetRespMat">SCgetRespMat</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_15">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>CMstep</code></dt>
<dd>
<p>CM step [rad] for <a href="#SCgetRespMat">SCgetRespMat</a>.</p>
</dd>
<dt class="hdlist1"><code>RFstep</code></dt>
<dd>
<p>RF frequency step [Hz] for <a href="#SCgetDispersion">SCgetDispersion</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_14">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>LOCOmeasData</code></dt>
<dd>
<p>Data structure containing the response matrix.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_11">EXAMPLES</h4>
<div class="paragraph">
<p>Get the orbit response matrix and the dispersion measurement using CM steps
of 0.1mrad and an rf frequency step of 1kHz, respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>LOCOmeasData =  SClocoLib('getMeasurement',SC,1E-4,1E3);</pre>
</div>
</div>
<div class="paragraph">
<p>Get the orbit response matrix and the dispersion measurement using a BPM variation
of 0.1mm and an rf frequency step of 1kHz, respectively and save the used CM steps.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[LOCOmeasData, CMsteps] =  SClocoLib('getMeasurement',SC,1E-4,1E3,'mode','fixedOffset');</pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_30">NAME</h4>
<div class="paragraph">
<p>setupFitparameters - Set up the LOCO fit parameter structure</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_30">SYNOPSIS</h4>
<div class="paragraph">
<p><code>FitParameters = SClocoLib('setupFitparameters', SC, RING0, RINGdata, RFstep [, parameters])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_30">DESCRIPTION</h4>
<div class="paragraph">
<p>Sets up the fit parameter structure which shall be used by <code>loco</code>.
Additionally the initial values of the fit parameters are stored, which is
needed in order to eventually apply the lattice correction.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_16">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>RING0</code></dt>
<dd>
<p>Initial (disturbed) lattice cell structure which was used for the response matrix measurement.</p>
</dd>
<dt class="hdlist1"><code>RINGdata</code></dt>
<dd>
<p>RING data structure.</p>
</dd>
<dt class="hdlist1"><code>RFstep</code></dt>
<dd>
<p>RF frequency step [Hz] for <code>locoresponsematrix</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_parameters">PARAMETERS</h4>
<div class="paragraph">
<p>Additional arguments are given as cell arrays and specify the
fit parameters.  Each cell must be given as {<code>ordinates</code>, <code>normal/skew</code>,
<code>individual/family</code>, <code>deltaK</code>} quadrupole, see examples.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_15">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>FitParameters</code></dt>
<dd>
<p>Fit parameter structure for <code>loco</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_12">EXAMPLES</h4>
<div class="paragraph">
<p>Set up the LOCO fit parameter structure using all <code>QF</code> and <code>QD</code> normal
quadrupoles (see also <a href="#SCgetOrds">SCgetOrds</a>) which are individually powered and using a
strength variation of 1E-3 and 1E-4 to calculate the derivatives,
respectively. The disturbed lattice <code>RING0</code> is used to identify the initial
setpoints of the fit parameters and an rf frequency step of 1kHz is assumed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ordQF = SCgetOrds(SC.RING,'QF');
ordQD = SCgetOrds(SC.RING,'QD');
FitParameters = SClocoLib('setupFitparameters',SC,RING0,RINGdata,1E3,...
	{ordQF,'normal','individual',1E-3},...
	{ordQD,'normal','individual',1E-4});</pre>
</div>
</div>
<div class="paragraph">
<p>Set up the LOCO fit parameter structure using all <code>QFA</code> normal quadrupoles
which are powered as a group (one fit parameter), using a strength variation
of 1E-4 to calculate the derivatives. The previously described structure
<code>Init</code> (see <code>'setupLOCOmodel'</code>) is used to identify the initial setpoints of
the fit parameters and an rf frequency step of 1kHz is assumed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FitParameters = SClocoLib('setupFitparameters',SC,Init.SC.RING,RINGdata,1E3,...
	{SCgetOrds(SC.RING,'QFA'),'normal','family',1E-4},...</pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_31">NAME</h4>
<div class="paragraph">
<p>applyLatticeCorrection - Applies the LOCO lattice correction</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_31">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SClocoLib('applyLatticeCorrection', SC, FitParameters)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_31">DESCRIPTION</h4>
<div class="paragraph">
<p>Applies the calculated lattice correction by adjusting the setpoints in
<code>SC.RING</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_17">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>FitParameters</code></dt>
<dd>
<p>Fit parameter structure (calculated by <code>loco</code>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_21">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'dipCompensation'</code> (1)</dt>
<dd>
<p>	Used for combined function quadrupoles (see <code>SCsetMags2SetPoints</code>). If this flag is set and if
there is a horizontal CM registered in the considered magnet, the CM is used to compensate
the bending angle difference if the applied quadrupole setpoints differs from the design value.</p>
</dd>
<dt class="hdlist1"><code>'damping'</code> (1)</dt>
<dd>
<p>Damping factor applied to each lattice correction step, e.g. <code>0.7</code> meaning that the correction
is only applied with 70% of it&#8217;s calculated amplitude.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_16">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure with applied lattice correction.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_32">NAME</h4>
<div class="paragraph">
<p>applyDiagnosticCorrection - Applies the LOCO result to BPMs and CMs</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_32">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SClocoLib('applyDiagnosticCorrection', SC, CMstep, CMData, BPMData [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_32">DESCRIPTION</h4>
<div class="paragraph">
<p>Corrects the BPM and CM errors in <code>SC</code> by applying the LOCO fit results. If quadrupoles are used
as CMs, the actual CM kick differs from the setpoint due to feed down effects. The (linear)
routine used by LOCO to calculate the response matrices does not include that effect. Thus, the
fitted CM calibration will differ from the actual calibration error of the CMs. This effect can be
mitigated by using the optional 'CMcalOffsets'. The option 'meanToZero' helps to deal with cases
where e.g. all fitted horizontal CM kicks are 2% too large while all horizontal BPM gains are 2%
too low.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_18">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>CMstep</code></dt>
<dd>
<p>CM step [rad] used in <code>getBPMCMstructure</code>.</p>
</dd>
<dt class="hdlist1"><code>BPMData</code></dt>
<dd>
<p>BPM data structure.</p>
</dd>
<dt class="hdlist1"><code>CMData</code></dt>
<dd>
<p>CM data structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_22">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'CMcalOffsets'</code> ([])</dt>
<dd>
<p>1x2 cell aray containg the horizontal and vertical CM calibration offsets</p>
</dd>
<dt class="hdlist1"><code>'meanToZero'</code> (0)</dt>
<dd>
<p>If true, the fitted calibration factors are subtracted by their mean value
before the correction is aplied</p>
</dd>
<dt class="hdlist1"><code>'outlierRemovalAt'</code> ([])</dt>
<dd>
<p>	If this option is set, any fitted calibration error above the threshold is
discarded and not applied to the SC structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_17">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure with applied correction to BPM and CM errors.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_33">NAME</h4>
<div class="paragraph">
<p>applyOrbitCorrection - Applies orbit correction</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_33">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SClocoLib('applyOrbitCorrection', SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_33">DESCRIPTION</h4>
<div class="paragraph">
<p>Applies orbit feedback using <a href="#SCfeedbackRun">SCfeedbackRun</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_19">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_23">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'Minv'</code> ([])</dt>
<dd>
<p>	Pseudo inverse of the response matrix. If not given explicitly,
	<a href="#SCgetModelRM">SCgetModelRM</a> is called and the Tikhonov regularization is used by
<a href="#SCgetPinv">SCgetPinv</a> to calculate <code>Minv</code>.</p>
</dd>
<dt class="hdlist1"><code>'alpha'</code> (50)</dt>
<dd>
<p>Tikhonov regularization parameter.</p>
</dd>
<dt class="hdlist1"><code>'CMords'</code> (SC.ORD.CM)</dt>
<dd>
<p>CM oridnates used for orbit correction.</p>
</dd>
<dt class="hdlist1"><code>'BPMords'</code> (SC.ORD.BPM)</dt>
<dd>
<p>BPM oridnates used for orbit correction.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_18">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure with applied orbit correction.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_34">NAME</h4>
<div class="paragraph">
<p>fitChromaticity - Fit chromaticity</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_34">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SClocoLib('fitChromaticity', SC, sFamOrds, [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_34">DESCRIPTION</h4>
<div class="paragraph">
<p>Applies a chromaticity correction using two sextupole families. The absolute initial
setpoint variation wihtin one family remains unchanged. Note:
this is not beam based but assumes the chromaticities can be measured reasonably well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_20">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>sFamOrds</code></dt>
<dd>
<p>[1x2] cell array of sextupole ordinates used for matching</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_24">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'targetChrom'</code> ([])</dt>
<dd>
<p>[1x2] array of target chromaticities. If not specified, the chromaticities as
calcualted from <code>SC.IDEALRING</code> are being used.</p>
</dd>
<dt class="hdlist1"><code>'InitStepSize'</code> ([2 2])</dt>
<dd>
<p>Initial step size for <code>fminsearch</code></p>
</dd>
<dt class="hdlist1"><code>'TolX'</code> (1E-4)</dt>
<dd>
<p>Step size tolerance used by <code>fminsearch</code></p>
</dd>
<dt class="hdlist1"><code>'TolFun'</code> (1E-3)</dt>
<dd>
<p>Merrit function tolerance used by <code>fminsearch</code></p>
</dd>
<dt class="hdlist1"><code>verbose</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_19">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure with corrected chromaticity.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_13">EXAMPLES</h4>
<div class="paragraph">
<p>Match the chromaticity in both planes to 1 using all magnets named <code>'SF'</code> and
<code>'SD'</code> (see also <a href="#SCgetOrds">SCgetOrds</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SClocoLib('fitChromaticity',SC,SCgetOrds(SC.RING,{'SF','SD'}),[1 1]);</pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_35">NAME</h4>
<div class="paragraph">
<p>fitTune - Fit tunes</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_35">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SClocoLib('fitTune', SC, qFamOrds, [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_35">DESCRIPTION</h4>
<div class="paragraph">
<p>Applies a tune correction using two quadrupole families. The absolute initial
setpoint variation wihtin one family, e.g. from LOCO remains unchanged. Note:
this is not beam based but assumes the tunes can be measured reasonably well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_21">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>qFamOrds</code></dt>
<dd>
<p>[1x2] cell array of quadrupole ordinates used for matching</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_25">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'FitInteger'</code> (1)</dt>
<dd>
<p>Flag specifying if the integer part should be fitted as well.</p>
</dd>
<dt class="hdlist1"><code>'targetTune'</code> ([])</dt>
<dd>
<p>[1x2] array of target tunes. If not specified, the tunes as
calcualted from <code>SC.IDEALRING</code> are being used.</p>
</dd>
<dt class="hdlist1"><code>'TolX'</code> (1E-4)</dt>
<dd>
<p>Step size tolerance used by <code>fminsearch</code></p>
</dd>
<dt class="hdlist1"><code>'InitStepSize'</code> ([.01 .01])</dt>
<dd>
<p>Initial step size for <code>fminsearch</code></p>
</dd>
<dt class="hdlist1"><code>'TolFun'</code> (1E-3)</dt>
<dd>
<p>Merrit function tolerance used by <code>fminsearch</code></p>
</dd>
<dt class="hdlist1"><code>verbose</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_20">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure with corrected chromaticity.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_14">EXAMPLES</h4>
<div class="paragraph">
<p>Match the fractional tunes in both planes to the ideal tunes using all
magnets named <code>'QF'</code> and <code>'QD'</code> (see also <a href="#SCgetOrds">SCgetOrds</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SClocoLib('fitTune',SC,SCgetOrds(SC.RING,{'QF','QD'}),'FitInteger',0);</pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_name_36">NAME</h4>
<div class="paragraph">
<p>plotStatus - Plots the current LOCO correction</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_36">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SClocoLib('plotStatus', SC, Init, BPMData, CMData)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_36">DESCRIPTION</h4>
<div class="paragraph">
<p>Plots the current beta beat, dispersion error and BPM and CM calibration and
roll errors.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_22">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>Init</code></dt>
<dd>
<p>Structure containing the initial <code>SC</code> structure and (disturbed) lattice
properties.</p>
</dd>
<dt class="hdlist1"><code>BPMData</code></dt>
<dd>
<p>BPM data structure.</p>
</dd>
<dt class="hdlist1"><code>CMData</code></dt>
<dd>
<p>CM data structure.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCmomentumAperture">SCmomentumAperture</h3>
<div class="sect3">
<h4 id="_name_37">NAME</h4>
<div class="paragraph">
<p>SCmomentumAperture - Calculates the momentum aperture</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_37">SYNOPSIS</h4>
<div class="paragraph">
<p><code>dbounds = SCmomentumAperture(RING, REFPTS, inibound [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_37">DESCRIPTION</h4>
<div class="paragraph">
<p>Calculates the momentum aperture of <code>RING</code> at the given <code>REFPTS</code>.  <code>dbounds</code>
is a <code>[2,length(REFPTS)]</code>-array containing the upper and lower bounds of the
local momentum aperture either the positive (default) or negative direction,
depending on the sign of <code>'inibounds'</code>, which is an initial guess for the
bounds of the momentum apeture. This is automatically refined in this
routine, so a rough guess is good enough.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_7">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>Lattice cell structure.</p>
</dd>
<dt class="hdlist1"><code>REFPTS</code></dt>
<dd>
<p><code>[1xN]</code> array of lattice ordinates at which the MA should be calculated.</p>
</dd>
<dt class="hdlist1"><code>inibounds</code></dt>
<dd>
<p><code>[inner,outer]</code> array of inner and outer bounds intial guess for the MA.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_26">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nturns'</code> (1000)</dt>
<dd>
<p>is the number of turns used to determine whether a particle is stable.</p>
</dd>
<dt class="hdlist1"><code>'accuracy'</code>(1e-4)</dt>
<dd>
<p>is the accuracy to which the momentum aperture is determined.</p>
</dd>
<dt class="hdlist1"><code>'stepsize'</code>(1e-3)</dt>
<dd>
<p>stepsize, with which the boundaries are expanded, when the critial
point is not within them.</p>
</dd>
<dt class="hdlist1"><code>'debug'</code> (0)</dt>
<dd>
<p>if true, debug information is printed.</p>
</dd>
<dt class="hdlist1"><code>'plot'</code> (0)</dt>
<dd>
<p>if true, results are plotted.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_globals_4">GLOBALS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>runParallel</code></dt>
<dd>
<p>If true, a parfor loop is executed instead of a regular for loop.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_21">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>dbounds</code></dt>
<dd>
<p><code>2xlength(REFPTS)</code> array containing the local momentum apertures
bounds.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_15">EXAMPLES</h4>
<div class="paragraph">
<p>Calculates the positive MA bounds for the first 10 lattice elements of <code>SC.RING</code> with
intial guess of [0,4E-2] over 1000 turns. Debug information is printed and the results
are plotted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>dbounds = SCmomentumAperture(SC.RING,1:10,[0,4E-2],'debug',1,'plot',1);</pre>
</div>
</div>
<div class="paragraph">
<p>Calculates the negative MA bounds at all <code>SD</code> magnets of <code>SC.RING</code> with the initial
guess of [-5E-3,-2E-2] over 10000 turns in parallel mode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'SD');
global runParallel
runParallel = 1;
dbounds = SCmomentumAperture(SC.RING,ords,[-5E-3,-2E-2],'nturns',10000);</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCmultipolesRead">SCmultipolesRead</h3>
<div class="sect3">
<h4 id="_name_38">NAME</h4>
<div class="paragraph">
<p>SCmultipolesRead - Reads multipole tables</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_38">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[AB, order, type] = SCmultipolesRead(fname)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_38">DESCRIPTION</h4>
<div class="paragraph">
<p>This functions reads multipole coefficients from the text-file <code>fname</code>, see
below for an example.
This file needs to contain all orders up to the maximum order; no gaps!
Lines starting with <code>#</code> are ignored.
Fields are delimited by tabs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_8">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>fname</code></dt>
<dd>
<p>File to read.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_15">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>AB</code></dt>
<dd>
<p><code>[2,maxorder]</code>-array containing the multipole coefficients</p>
</dd>
<dt class="hdlist1"><code>order</code>, <code>type</code></dt>
<dd>
<p>If the multipole table contains an exact <code>1.0</code>, it is assumed
this table is scaled to that coefficient. In that case
<code>order</code> gives the <code>n</code> of that coefficent and <code>type</code> determines
whether it is the normal (2) or skew (1) component.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_example_file">EXAMPLE FILE</h4>
<div class="listingblock">
<div class="content">
<pre># Taken from v20r_SysMultipoles_R1.xlsx (table DIPA, AT conv)
# This is a comment.
# n	PolynomA(n)		PolynomB(n)
0	+0.000000000E+00	-1.712194700E-01
1	+0.000000000E+00	+2.997864116E+00
2	+0.000000000E+00	+1.121256852E+00
3	+0.000000000E+00	-5.000867669E+01
4	+0.000000000E+00	-4.233346976E+03
5	+0.000000000E+00	-6.454146352E+05
6	+0.000000000E+00	-4.014924846E+07
7	+0.000000000E+00	-8.862779057E+09
8	+0.000000000E+00	+2.614134332E+12
9	+0.000000000E+00	-5.382882472E+14</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCparticlesIn3D">SCparticlesIn3D</h3>
<div class="sect3">
<h4 id="_name_39">NAME</h4>
<div class="paragraph">
<p>SCparticlesIn3D - Re-order particle trajectories</p>
</div>
</div>
<div class="sect3">
<h4 id="_description_39">DESCRIPTION</h4>
<div class="paragraph">
<p><code>atpass</code> gives its result in form of an <code>6x(NPART NELEM*NTURN)</code> array, where
<code>NPART</code>/<code>NELEM</code>/<code>NTURN</code> are the number of particles/elements/turns.
This function takes this output and reorders it into an 3D array with
dimensions <code>6x(NELEM*NTURN)xNPART</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_9">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>R</code></dt>
<dd>
<p>Output of <code>atpass</code>.</p>
</dd>
<dt class="hdlist1"><code>NPART</code></dt>
<dd>
<p>Number of particles in <code>R</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return">RETURN</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>M</code></dt>
<dd>
<p>3D array in with dimensions <code>6x(NELEM*NTURN)xNPART</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCplotBPMreading">SCplotBPMreading</h3>
<div class="sect3">
<h4 id="_name_40">NAME</h4>
<div class="paragraph">
<p>SCplotBPMreading - plots BPM readings and particle trajectories</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_39">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCplotBPMreading(SC, B, T)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_40">DESCRIPTION</h4>
<div class="paragraph">
<p><code>SCplotBPMreading</code> is a plotting function used by <a href="#SCgetBPMreading">SCgetBPMreading</a> and plots the BPM readings and
particel trajectories including the aperture model. Note that the BPM readings mus include all
registered BPMs and the trajectories must be evaluated at all lattice elements.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_23">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>B</code></dt>
<dd>
<p>BPM readings</p>
</dd>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>Trajectories</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_18">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetBPMreading">SCgetBPMreading</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCplotCMstrengths">SCplotCMstrengths</h3>
<div class="sect3">
<h4 id="_name_41">NAME</h4>
<div class="paragraph">
<p>SCplotCMstrengths - plots the current CM setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_40">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCplotCMstrengths(SC)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_41">DESCRIPTION</h4>
<div class="paragraph">
<p>Plots the current CM setpoints.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_24">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_19">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCplotLattice">SCplotLattice</h3>
<div class="sect3">
<h4 id="_name_42">NAME</h4>
<div class="paragraph">
<p>SCplotLattice - Plots the lattice including the location of BPMs and CMs</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_41">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCplotLattice(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_42">DESCRIPTION</h4>
<div class="paragraph">
<p>This function plots the lattice functions as well as the distribution of registered magnets
including CMs and BPMs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_25">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_27">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'transferLine'</code> (0)</dt>
<dd>
<p>If true the function 'twissline' is used to calculate the lattice functions</p>
</dd>
<dt class="hdlist1"><code>'sRange'</code> ([])</dt>
<dd>
<p>Array ['sMin','sMax'] defining the plot range [m].</p>
</dd>
<dt class="hdlist1"><code>'oList'</code> ([])</dt>
<dd>
<p>If <code>'sRange'</code> is empty, <code>'oList'</code>  can be used to specify a list of ordinates at which the lattice should be plotted</p>
</dd>
<dt class="hdlist1"><code>'nSectors'</code> (1)</dt>
<dd>
<p>If <code>'oList'</code> is empty, <code>'nSectors'</code> can be used to plot only the first fraction of the lattice</p>
</dd>
<dt class="hdlist1"><code>'plotIdealRing'</code> (1)</dt>
<dd>
<p>Specify if 'SC.IDEALRING' should be used to plot twiss functions, otherwise 'SC.RING'.</p>
</dd>
<dt class="hdlist1"><code>'plotMagNames'</code> (0)</dt>
<dd>
<p>Specify if magnet names should be printed next to the magnets. Note: since Matlab is not able to
find the best placement of text annotations automatically, it is likely required that the
corresponding lines in the code are adjusted to the users discretion.</p>
</dd>
<dt class="hdlist1"><code>'fontSize'</code> (16)</dt>
<dd>
<p>Figure font size.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_16">EXAMPLES</h4>
<div class="paragraph">
<p>Plots the complete lattice for a ring</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SCplotLattice(SC);</pre>
</div>
</div>
<div class="paragraph">
<p>Plots the lattice from ordinate 30 to 130 for a transfer line</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SCplotLattice(SC,'transferLine',1,'oList',30:120);</pre>
</div>
</div>
<div class="paragraph">
<p>Plots the lattice of one arc for a twelfe-fold symmetric ring lattice</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SCplotLattice(SC,'nSectors',12);</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCplotLattice_backup220627">SCplotLattice</h3>
<div class="sect3">
<h4 id="_name_43">NAME</h4>
<div class="paragraph">
<p>SCplotLattice - Plots the lattice including the location of BPMs and CMs</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_42">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCplotLattice(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_43">DESCRIPTION</h4>
<div class="paragraph">
<p>This function plots the lattice functions as well as the distribution of registered magnets
including CMs and BPMs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_26">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_28">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'transferLine'</code> (0)</dt>
<dd>
<p>If true the function 'twissline' is used to calculate the lattice functions</p>
</dd>
<dt class="hdlist1"><code>'sRange'</code> ([])</dt>
<dd>
<p>Array ['sMin','sMax'] defining the plot range [m].</p>
</dd>
<dt class="hdlist1"><code>'oList'</code> ([])</dt>
<dd>
<p>If <code>'sRange'</code> is empty, <code>'oList'</code>  can be used to specify a list of ordinates at which the lattice should be plotted</p>
</dd>
<dt class="hdlist1"><code>'nSectors'</code> (1)</dt>
<dd>
<p>If <code>'oList'</code> is empty, <code>'nSectors'</code> can be used to plot only the first fraction of the lattice</p>
</dd>
<dt class="hdlist1"><code>'plotIdealRing'</code> (1)</dt>
<dd>
<p>Specify if 'SC.IDEALRING' should be used to plot twiss functions, otherwise 'SC.RING'.</p>
</dd>
<dt class="hdlist1"><code>'plotMagNames'</code> (0)</dt>
<dd>
<p>Specify if magnet names should be printed next to the magnets. Note: since Matlab is not able to
find the best placement of text annotations automatically, it is likely required that the
corresponding lines in the code are adjusted to the users discretion.</p>
</dd>
<dt class="hdlist1"><code>'fontSize'</code> (16)</dt>
<dd>
<p>Figure font size.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_17">EXAMPLES</h4>
<div class="paragraph">
<p>Plots the complete lattice for a ring</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SCplotLattice(SC);</pre>
</div>
</div>
<div class="paragraph">
<p>Plots the lattice from ordinate 30 to 130 for a transfer line</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SCplotLattice(SC,'transferLine',1,'oList',30:120);</pre>
</div>
</div>
<div class="paragraph">
<p>Plots the lattice of one arc for a twelfe-fold symmetric ring lattice</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SCplotLattice(SC,'nSectors',12);</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCplotPhaseSpace">SCplotPhaseSpace</h3>
<div class="sect3">
<h4 id="_name_44">NAME</h4>
<div class="paragraph">
<p>SCplotPhaseSpace - Plots the turn-by-turn phase space</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_43">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCplotPhaseSpace(SC [,options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_44">DESCRIPTION</h4>
<div class="paragraph">
<p>Plots the horizontal, vertical and longitudinal turn-by-turn phase space for a bunch of particles
as specified in the injection pattern <code>SC.INJ</code>. If <code>'RFCavityPass'</code> is the specified cavity pass
method, the slippage length per turn caused by a potential frequency error is calculated and the
longitudinal coordinate is adjusted for plotting.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_27">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_29">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name-vale pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nTurns'</code> (<code>SC.INJ.nTurns</code>)</dt>
<dd>
<p>Number of turns.</p>
</dd>
<dt class="hdlist1"><code>'nParticles'</code> (<code>SC.INJ.nParticles</code>)</dt>
<dd>
<p>Number of particles.</p>
</dd>
<dt class="hdlist1"><code>'ord'</code> (1)</dt>
<dd>
<p>Ordinate for plotting.</p>
</dd>
<dt class="hdlist1"><code>'plotCO'</code> (0)</dt>
<dd>
<p>Logical value defining if closed orbit should be plotted as well.</p>
</dd>
<dt class="hdlist1"><code>'customBunch'</code> ([])</dt>
<dd>
<p>[6 x N] array of particle start points for phase space evaluation. If not specified a bunch is
generated using <a href="#SCgenBunches">SCgenBunches</a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCplotSupport">SCplotSupport</h3>
<div class="sect3">
<h4 id="_name_45">NAME</h4>
<div class="paragraph">
<p>SCplotSupport - Plots the offset and rolls of magnets, the support structure and BPMs</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_44">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCplotSupport(SC)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_45">DESCRIPTION</h4>
<div class="paragraph">
<p>This function plots the overall offsets [dx,dy,dz] and rolls [az,ax,ay] of all magnets and BPMs,
as well as the individual contributions from different support structures (if registered).
Please note that the apperance of the figure significanlty depends on the lattice (magnitude of
errors or lattice size) and the used computer (screen size, Matlab version). The user might have
to adjust plot apperance properties.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_28">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_30">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'fontSize'</code> (12)</dt>
<dd>
<p>Figure font size.</p>
</dd>
<dt class="hdlist1"><code>'shiftAxes'</code> (0.03)</dt>
<dd>
<p>Axes are reanranged for grouping. Depending on screen resolution this value may be adjusted.</p>
</dd>
<dt class="hdlist1"><code>'xLim'</code> ([0 findspos(SC.RING,length(SC.RING)+1)])</dt>
<dd>
<p>Plot limits.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_20">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCgetSupportOffset">SCgetSupportOffset</a>, <a href="#SCgetSupportRoll">SCgetSupportRoll</a>, <a href="#SCupdateSupport">SCupdateSupport</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCpseudoBBA">SCpseudoBBA</h3>
<div class="sect3">
<h4 id="_name_46">NAME</h4>
<div class="paragraph">
<p>SCpseudoBBA - mimics the results of a BBA procedure</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_45">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC] = SCpseudoBBA(SC, BPMords, MagOrds, postBBAoffset)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_46">DESCRIPTION</h4>
<div class="paragraph">
<p>Sets the BPM offsets to values as would be achieved by performing a BBA procedure. The BPMs
defined in <code>BPMords</code> are paired with the magnets defined in <code>MagOrds</code> and the BPM offsets
are adjusted to match the magnet offsets with an accuracy of <code>postBBAoffset</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_10">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>BPMords</code></dt>
<dd>
<p>[2 x N] array of BPM ordinates.</p>
</dd>
<dt class="hdlist1"><code>MagOrds</code></dt>
<dd>
<p>[2 x N] array of magnet ordinates.</p>
</dd>
<dt class="hdlist1"><code>postBBAoffset</code></dt>
<dd>
<p>[2 x N] array or single value of rms accuracy of pseudo BBA procedure [m].</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_31">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be specified as name-value pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'sigma'</code> (<code>2</code>)</dt>
<dd>
<p>Cutoff (number of sigmas) for generating the final offset distribution.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_16">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC-structure with adjusted BPM offsets.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_18">EXAMPLES</h4>
<div class="paragraph">
<p>Assuming that each QF, QD and QFA magnet is accompanied by one BPM, the following assumes a
sucessful BBA routine and assigns a 50um BPM offset w.r.t. the magnet centers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>QuadOrds = repmat(SCgetOrds(SC.RING,'QF|QD|QFA'),2,1);
SC = SCpseudoBBA(SC,SC.ORD.BPM,QuadOrds,50E-6);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_21">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetOrds">SCgetOrds</a>, <a href="#SCBBA">SCBBA</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCrampUpErrors">SCrampUpErrors</h3>
<div class="sect3">
<h4 id="_name_47">NAME</h4>
<div class="paragraph">
<p>SCrampUpErrors - Ramps up errors while applying trajectory/orbit feedback</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_46">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[SC, ERROR] = SCrampUpErrors(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_47">DESCRIPTION</h4>
<div class="paragraph">
<p>This function may be used as a shortcut to the result of start-to-end correction chain. The
input is the SC structure containing a <code>SC.RING</code> with already applied errors. <a href="#SCrampUpErrors">SCrampUpErrors</a>
then ramps up these errors in steps while applying <a href="#SCfeedbackRun">SCfeedbackRun</a>. If ramping
up fails, the number of steps is doubled and the procedure starts over until the number of steps
exceeds 100.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_11">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The base structure containing <code>SC.RING</code> with applied errors</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_17">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The base structure containing <code>SC.RING</code> with applied errors and a corrected orbit</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_32">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nStepsRamp'</code> (10)</dt>
<dd>
<p>Number of steps for ramping up errors.</p>
</dd>
<dt class="hdlist1"><code>'alpha'</code> (10)</dt>
<dd>
<p>Regularization parameter to get the pseudo inverse of the response matrix.</p>
</dd>
<dt class="hdlist1"><code>'target'</code> (0)</dt>
<dd>
<p>(for feedback) break, if the RMS BPM reading reaches this value</p>
</dd>
<dt class="hdlist1"><code>'maxsteps'</code> (30)</dt>
<dd>
<p>(for feedback) break, if this number of correction steps have been performed</p>
</dd>
<dt class="hdlist1"><code>'eps'</code> (<code>1e-5</code>)</dt>
<dd>
<p>(for feedback) break, if the coefficient of variation of the RMS BPM reading is below
this value</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_19">EXAMPLES</h4>
<div class="paragraph">
<p>Initialize <code>SC</code> with the lattice <code>RING</code>, apply the user defined function <code>registerRING</code> to
register all required elements including uncertainties of the magnets, BPMs, RF, etc. In the next
step the errors are applied by <a href="#SCapplyErrors">SCapplyErrors</a>. Tracking is set to orbit mode and the previously
applied errors are ramped up in 15 steps. If <code>err=0</code>, the output contains <code>SC.RING</code> with applied
errors and a corrected closed orbit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCinit(RING);
SC = registerRING(SC);
SC = SCapplyErrors(SC);
SC.INJ.trackMode = 'ORB';
[SC,err] = SCrampUpErrors(SC,'nStepsRamp',15);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_22">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCregisterBPMs">SCregisterBPMs</a>, <a href="#SCregisterCAVs">SCregisterCAVs</a>, <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCgetModelRM">SCgetModelRM</a>, <a href="#SCgetPinv">SCgetPinv</a>,  <a href="#SCfeedbackRun">SCfeedbackRun</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCrandnc">SCrandnc</h3>
<div class="sect3">
<h4 id="_name_48">NAME</h4>
<div class="paragraph">
<p>SCrandnc - Truncated Gaussian random number generator</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_47">SYNOPSIS</h4>
<div class="paragraph">
<p><code>out = SCrandnc(c, [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_48">DESCRIPTION</h4>
<div class="paragraph">
<p>Random number generator (Gaussian distribution with mean 0 and sigma of 1). This function calls
the built in Matlab function randn but allows to specify a cut parameter <code>c</code>. Only numbers between
<code>-c</code> and <code>+c</code> will be generated.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_29">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>c</code></dt>
<dd>
<p>cutoff value</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_33">OPTIONS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>size</code></dt>
<dd>
<p>Either [<code>M</code>, <code>N</code>] array defining the size of the output array or two values <code>M</code>, <code>N</code>. See examples.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_18">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>output</code></dt>
<dd>
<p>[<code>M</code> x <code>N</code>] array of random numbers with a Gaussian distribution</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_20">EXAMPLES</h4>
<div class="paragraph">
<p>Generates a random number <code>out</code> between [-2,2] and with sigma=1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>out = SCrandnc(2);</pre>
</div>
</div>
<div class="paragraph">
<p>Generates random numbers <code>out</code> between [-2,2] and with sigma=1 with size(out)=size(A).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>out = SCrandnc(2,size(A));</pre>
</div>
</div>
<div class="paragraph">
<p>Generates random numbers <code>out</code> between [-2,2] and with sigma=1 with size(out)=[1,10].</p>
</div>
<div class="listingblock">
<div class="content">
<pre>out = SCrandnc(2,1,10);</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCregisterBPMs">SCregisterBPMs</h3>
<div class="sect3">
<h4 id="_name_49">NAME</h4>
<div class="paragraph">
<p>SCregisterBPMs - Registers BPMs in SC</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_48">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCregisterBPMs(SC,BPMords [, sigmas])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_49">DESCRIPTION</h4>
<div class="paragraph">
<p>Registers BPMs specified by <code>BPMords</code> in the <code>SC</code> structure and initializes all required fields
in the lattice elements. The ordinates of all registered BPMs are stored in <code>SC.ORD.BPM</code>. The
BPM realated fields in the lattice elements are</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Noise</code></dt>
<dd>
<p>[1 x 2] array of hor./ver. turn-by-turn BPM noise</p>
</dd>
<dt class="hdlist1"><code>NoiseCO</code></dt>
<dd>
<p>[1 x 2] array of hor./ver. orbit BPM noise</p>
</dd>
<dt class="hdlist1"><code>CalError</code></dt>
<dd>
<p>[1 x 2] array of hor./ver. BPM calibration errors</p>
</dd>
<dt class="hdlist1"><code>Offset</code></dt>
<dd>
<p>[1 x 2] array of individual hor./ver. BPM offsets</p>
</dd>
<dt class="hdlist1"><code>SupportOffset</code></dt>
<dd>
<p>[1 x 2] array of hor./ver. BPM offsets which result from the corresponding girder offset at
the location of the BPMs, see <a href="#SCupdateSupport">SCupdateSupport</a>.</p>
</dd>
<dt class="hdlist1"><code>Roll</code></dt>
<dd>
<p>BPM roll around z-axis w.r.t. the support structure</p>
</dd>
<dt class="hdlist1"><code>SupportRoll</code></dt>
<dd>
<p>BPM roll around z-axis which results from the corresponding support structure roll at
the location of the BPMs, see <a href="#SCupdateSupport">SCupdateSupport</a>.</p>
</dd>
<dt class="hdlist1"><code>SumError</code></dt>
<dd>
<p>Calibration error of the sum signal. The sum signal is used to determine the beam loss location
with a cutoff as defined <code>SC.INJ.beamLostAt</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_30">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>BPMords</code></dt>
<dd>
<p>BPM ordinates in the lattice structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_uncertainties">UNCERTAINTIES</h4>
<div class="paragraph">
<p>Additional name/vale-pairs are interpreted as uncertainties and passed to the sigma structure
<code>SC.SIG</code> for the corresponding BPM. The function <a href="#SCapplyErrors">SCapplyErrors</a> uses the fields of <code>SC.SIG</code> to
randomly generate errors and applies them to the corresponding fields in <code>SC.RING</code>.
By default a 2 sigma cutoff is applied. The user can specify a different cutoff by giving the
uncertainty as a cell structure, e.g. {[1x2],nSig}, with nSig being the cutoff (see examples
below).</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_22">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The base structure containing required information of all BPMs.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_21">EXAMPLES</h4>
<div class="paragraph">
<p>Identify the ordinates of all elements named <code>BPM</code> and registers them as BPMs in <code>SC</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'BPM');
SC = SCregisterBPMs(SC,ords);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the BPMs specified in <code>ords</code> in <code>SC</code> and set the uncertanty of the offset to <code>500um</code> in
both planes. A subsequent call of <a href="#SCapplyErrors">SCapplyErrors</a> would generate a random BPM offset errors with
<code>sigma=500um</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterBPMs(SC,ords,'Offset',500E-6*[1 1]);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the BPMs specified in <code>ords</code> in <code>SC</code> and set the uncertanty of the offset to <code>500um</code> in
both planes and a calibration error of the sum signal of 20%.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterBPMs(SC,ords,'Offset',500E-6*[1 1],'SumError',0.2);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the BPMs specified in <code>ords</code> in <code>SC</code> and set the uncertanty of the offset to <code>500um</code> in
both planes. A subsequent call of <a href="#SCapplyErrors">SCapplyErrors</a> would generate a random BPM offset errors with
<code>sigma=500um</code> with a 3 sigma cutoff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterBPMs(SC,ords,'Offset',{500E-6*[1 1],3});</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_23">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCgetOrds">SCgetOrds</a>, <a href="#SCsanityCheck">SCsanityCheck</a>, <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCupdateSupport">SCupdateSupport</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCregisterCAVs">SCregisterCAVs</h3>
<div class="sect3">
<h4 id="_name_50">NAME</h4>
<div class="paragraph">
<p>SCregisterCAVs - Register cavities in SC</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_49">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCregisterCAVs(SC,CAVords [, sigmas])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_50">DESCRIPTION</h4>
<div class="paragraph">
<p>Register cavities specified in <code>CAVords</code> in <code>SC</code> by initializing all required fields in the
corresponding cavity lattice elements and storing the ordinates in <code>SC.ORD.Cavity</code>. The additional
fields in the lattice elements are</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>VoltageSetPoint</code></dt>
<dd>
<p>Setpoint of cavity voltage</p>
</dd>
<dt class="hdlist1"><code>VoltageOffset</code></dt>
<dd>
<p>Offset of cavity voltage wrt. to the setpoint</p>
</dd>
<dt class="hdlist1"><code>VoltageCalError</code></dt>
<dd>
<p>Calibration error of cavity voltage wrt. to the setpoint</p>
</dd>
<dt class="hdlist1"><code>FrequencySetPoint</code></dt>
<dd>
<p>Setpoint of cavity frequency</p>
</dd>
<dt class="hdlist1"><code>FrequencyOffset</code></dt>
<dd>
<p>Offset of cavity frequency wrt. to the setpoint</p>
</dd>
<dt class="hdlist1"><code>FrequencyCalError</code></dt>
<dd>
<p>Calibration error of cavity frequency wrt. to the setpoint</p>
</dd>
<dt class="hdlist1"><code>TimeLagSetPoint</code></dt>
<dd>
<p>Setpoint of cavity phase (<code>TimeLag</code>)</p>
</dd>
<dt class="hdlist1"><code>TimeLagOffset</code></dt>
<dd>
<p>Offset of cavity phase wrt. to the setpoint</p>
</dd>
<dt class="hdlist1"><code>TimeLagCalError</code></dt>
<dd>
<p>Calibration error of cavity phase wrt. to the setpoint</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_31">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>CAVords</code></dt>
<dd>
<p>Cavity ordinates in the lattice structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_uncertainties_2">UNCERTAINTIES</h4>
<div class="paragraph">
<p>Additional name/vale-pairs are interpreted as uncertainties and passed to the sigma structure
<code>SC.SIG</code> for the corresponding cavity. The function <a href="#SCapplyErrors">SCapplyErrors</a> uses the fields of <code>SC.SIG</code>
to randomly generate errors and applies them to the corresponding fields of the lattice element.
By default a 2 sigma cutoff is applied. The user can specify a different cutoff by giving the
uncertainty as a cell structure, e.g. {deltaF,nSig}, with nSig being the cutoff (see examples
below).</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_23">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The base structure containing required information of all cavities.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_22">EXAMPLES</h4>
<div class="paragraph">
<p>Identify the ordinates of all elements named <code>'CAV'</code> and register them as cavities in <code>SC</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'CAV');
SC = SCregisterCAVs(SC,ords);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the cavities specified in <code>ords</code> in <code>SC</code> and sets the uncertanty of the frequency offset
to 1kHz. A subsequent call of <a href="#SCapplyErrors">SCapplyErrors</a> would generate a random frequncy offset error with
<code>sigma=1kHz</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterCAVs(SC,ords,'FrequencyOffset',1E3);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the cavities specified in <code>ords</code> in <code>SC</code> and sets the uncertanty of the frequency offset
to 1kHz. A subsequent call of <a href="#SCapplyErrors">SCapplyErrors</a> would generate a random frequncy offset error with
<code>sigma=1kHz</code> and a 3 sigma cutoff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterCAVs(SC,ords,'FrequencyOffset',{1E3,3});</pre>
</div>
</div>
<div class="paragraph">
<p>Register the cavities specified in <code>ords</code> in <code>SC</code> and sets the uncertanty of the timelag offset
to 0.3m. A subsequent call of <a href="#SCapplyErrors">SCapplyErrors</a> would generate a random timelag offset error
('phase error') with <code>sigma=0.3m</code> and a 3 sigma cutoff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterCAVs(SC,ords,'TimeLagOffset',{0.3,3});</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_24">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetOrds">SCgetOrds</a>, <a href="#SCsanityCheck">SCsanityCheck</a>, <a href="#SCapplyErrors">SCapplyErrors</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCregisterMagnets">SCregisterMagnets</h3>
<div class="sect3">
<h4 id="_name_51">NAME</h4>
<div class="paragraph">
<p>SCregisterMagnets - Register magnets in SC</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_50">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCregisterMagnets(SC, MAGords [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_51">DESCRIPTION</h4>
<div class="paragraph">
<p>Registers magnets specified by <code>MAGords</code> in the <code>SC</code> structure and initializes all required fields
in the lattice elements. The ordinates of all registered magnets are stored in <code>SC.ORD.Magnet</code>.
The additional <code>SC</code> related fields in the lattice elements are</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NomPolynomB</code></dt>
<dd>
<p>Nominal (design) <code>PolynomB</code> fields.</p>
</dd>
<dt class="hdlist1"><code>NomPolynomA</code></dt>
<dd>
<p>Nominal (design) <code>PolynomA</code> fields.</p>
</dd>
<dt class="hdlist1"><code>SetPointB</code></dt>
<dd>
<p>Setpoints for the <code>PolynomB</code> fields.</p>
</dd>
<dt class="hdlist1"><code>SetPointA</code></dt>
<dd>
<p>Setpoints for the <code>PolynomA</code> fields.</p>
</dd>
<dt class="hdlist1"><code>CalErrorB</code></dt>
<dd>
<p>Calibration error of the <code>PolynomB</code> fields wrt. the corresponding setpoints.</p>
</dd>
<dt class="hdlist1"><code>CalErrorA</code></dt>
<dd>
<p>Calibration error of the <code>PolynomA</code> fields wrt. the corresponding setpoints.</p>
</dd>
<dt class="hdlist1"><code>PolynomBOffset</code> (optional)</dt>
<dd>
<p>Offset error of the <code>PolynomB</code> fields wrt. the corresponding setpoints.</p>
</dd>
<dt class="hdlist1"><code>PolynomAOffset</code> (optional)</dt>
<dd>
<p>Offset error of the <code>PolynomA</code> fields wrt. the corresponding setpoints.</p>
</dd>
<dt class="hdlist1"><code>MagnetOffset</code></dt>
<dd>
<p>[1 x 3] array of horizontal, vertical and longitudinal magnet offsets (wrt. the support
structure).</p>
</dd>
<dt class="hdlist1"><code>SupportOffset</code></dt>
<dd>
<p>[1 x 3] array of horizontal, vertical and longitudinal  support structure offsets (if
support structure is registered).</p>
</dd>
<dt class="hdlist1"><code>MagnetRoll</code></dt>
<dd>
<p>[1x3] array [az,ax,ay] defineing magnet roll (around z-axis), pitch (roll around x-axis)
and yaw (roll around y-axis); all wrt. the support structure.</p>
</dd>
<dt class="hdlist1"><code>SupportRoll</code></dt>
<dd>
<p>[1x3] array [az,ax,ay] defineing support structure roll (around z-axis), pitch (roll
around x-axis) and yaw (roll around y-axis); all wrt. the design coordinate frame (if
support structure is registered).</p>
</dd>
<dt class="hdlist1"><code>BendingAngleError</code> (optional)</dt>
<dd>
<p>Error of the main bending field (corresponding uncertainty defined with <code>BendingAngle</code>).</p>
</dd>
<dt class="hdlist1"><code>CF</code> (optional)</dt>
<dd>
<p>Flag identifying the corresponding magnet as a combined function dipole/quadrupole.</p>
</dd>
<dt class="hdlist1"><code>HCM</code> (optional)</dt>
<dd>
<p>Flag identifying the corresponding magnet as a horizontal corrector magnet.</p>
</dd>
<dt class="hdlist1"><code>VCM</code> (optional)</dt>
<dd>
<p>Flag identifying the corresponding magnet as a vertical corrector magnet.</p>
</dd>
<dt class="hdlist1"><code>SkewQuad</code> (optional)</dt>
<dd>
<p>Flag identifying the corresponding magnet as a skew quadrupole corrector magnet.</p>
</dd>
<dt class="hdlist1"><code>MasterOf</code> (optional)</dt>
<dd>
<p>Array of ordinates to which the corresponding magnet acts as master (split magnets).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Optional input arguments can be given as name/value-pairs and are either used
to specify certain magnet types or to define uncertainties (see below).
If CMs or skew quadrupole correctors are specified, the ordinates are also
stored in the corresponding fields <code>SC.ORD.CM</code> and <code>SC.ORD.SkewQuad</code>,
respectively.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_32">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>MAGords</code></dt>
<dd>
<p>Magnet ordinates in the lattice structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_34">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'HCM'</code> ([])</dt>
<dd>
<p>Magnet is identified as horizontal CM.
The corresponding value is the horizontal CM limit and stored in
<code>SC.RING{MAGords}.CMlimit(1)</code>. E.g. set limit to <code>Inf</code>.</p>
</dd>
<dt class="hdlist1"><code>'VCM'</code> ([])</dt>
<dd>
<p>Magnet is identified as vertical CM.
The corresponding value is the vertical CM limit and stored in
<code>SC.RING{MAGords}.CMlimit(2)</code>. E.g. set limit to <code>Inf</code>.</p>
</dd>
<dt class="hdlist1"><code>'SkewQuad'</code> ([])</dt>
<dd>
<p>Magnet is identified as skew quadrupole corrector.
The corresponding value is the skew quadrupole limit and stored in
<code>SC.RING{MAGords}.SkewLimit</code>. E.g. set limit to <code>Inf</code>.</p>
</dd>
<dt class="hdlist1"><code>'CF'</code> (0)</dt>
<dd>
<p>If true, the magnet is identified as a combined function
dipole/quadrupole.
That implies that the bending angle depends on the quadrupole setpoint.
A variation from the design value will therefore result in a bending
angle error which is added to the <code>PolynomB(1)</code> field.</p>
</dd>
<dt class="hdlist1"><code>'MasterOf'</code> ([])</dt>
<dd>
<p>The magnets <code>MAGords</code> are identified as a split magnets each with <code>N</code>
childs as specified in the corresponding value which must be a [<code>N</code> x
<code>length(MAGords)</code>] array.
The field calculation in <a href="#SCupdateMagnets">SCupdateMagnets</a> uses the setpoints and
errors of the master magnet to calculate the child fields.
The relative bending angle error of the master magnet e.g. is applied
on the corresponding child bending angle appropriately.
Split quadrupole magnets with different design gradients, however, can
currently not be updated correctly.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_uncertainties_3">UNCERTAINTIES</h4>
<div class="paragraph">
<p>Every name/value-pair which is not explicitly mentioned in the options above
is interpreted as an uncertainty and passed to the sigma structure <code>SC.SIG</code>
for the corresponding magnets defined in <code>MAGords</code> (see examples below).
The function <a href="#SCapplyErrors">SCapplyErrors</a> uses the fields of <code>SC.SIG</code> to randomly generate
errors and applies them to the corresponding fields of the lattice elements.
By default, a Gaussian distribution with a cutoff at 2 sigma is applied. An
alternative cutoff value can be given explicitly for each uncertainty type,
see examples below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_23">EXAMPLES</h4>
<div class="paragraph">
<p>Identify the ordinates of all elements named <code>QF</code> and register them in <code>SC</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'QF');
SC = SCregisterMagnets(SC,ords);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> and set the uncertainty of
the quadrupole component to 1E-3 and 30um horizontal and vertical offset.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'CalErrorB',[0 1E-3],...
	'MagnetOffset',[30E-6 30E-6 0]);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> and set the uncertainty of
the quadrupole component to 1E-3 and 30um horizontal and vertical offset with
a 3 sigma cutoff value (when applied with <a href="#SCapplyErrors">SCapplyErrors</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'CalErrorB',[0 1E-3],...
	'MagnetOffset',{[30E-6 30E-6 0],3});</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> and set the uncertainty of
the quadrupole component to 1E-3, 30um horizontal and vertical offset and
100um longitudinal offset.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'CalErrorB',[0 1E-3],...
	'MagnetOffset',[30E-6 30E-6 100E-6]);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> and set the uncertainty of
the roll, pitch and yaw angle to 100urad.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'Roll',[100E-6 100E-6 100E-6]);</pre>
</div>
</div>
<div class="paragraph">
<p>Register split magnets.
Identify the magnets named <code>BENDa</code> ([<code>1xN</code>] array <code>masterOrds</code>) and the
magnets named <code>BENDb</code> and <code>BENDc</code> ([<code>2xN</code>] array <code>childOrds</code>) and register
the <code>masterOrds</code> as the master magnets of the children in the corresponding
columns of <code>childOrds</code>.
The uncertanty of the bending angle is set to 1E-4.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>masterOrds = SCgetOrds(SC.RING,'BENDa');
childOrds  = [SCgetOrds(SC.RING,'BENDb');SCgetOrds(SC.RING,'BENDc')];
SC = SCregisterMagnets(SC,masterOrds, ...
	'BendingAngle',1E-4,
	'MasterOf',childOrds);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> and set the uncertainty of
the quadrupole component to 1E-3 and the uncertainty of the bending angle to
1E-4, the latter with a 3 sigma cutoff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'CalErrorB',[0 1E-3], ...
	'BendingAngle',{1E-4,3});</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> as combined function magnets
and sets the uncertanty of the quadrupole component to 1E-3.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'CF',1, ...
	'CalErrorB',[0 1E-3]);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> and set the uncertanty of
the skew quadrupole component to 2E-3 and the uncertanty of the sextupole
component to 1E-3.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'CalErrorA',[0 2E-3 0], ...
	'CalErrorB',[0 0 1E-3]);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> as horizontal and vertical
CMs, set their dipole uncertanties to 5% and 1%, respectively and define no
CM limits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'HCM',Inf, ...
	'VCM',Inf, ...
	'CalErrorB',5E-2, ...
	'CalErrorA',1E-2);</pre>
</div>
</div>
<div class="paragraph">
<p>Register the magnets specified in <code>ords</code> in <code>SC</code> as horizontal and vertical
CMs, set their uncertanties to 5% and 1%, respectively and their limits to 1
mrad. Furthermore, set the uncertanty of the skew quadrupole component to
2E-3 and the uncertanty of the sextupole component to 1E-3.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterMagnets(SC,ords, ...
	'HCM',1E-3, ...
	'VCM',1E-3, ...
	'CalErrorB',[5E-2 0 1E-3], ...
	'CalErrorA',[1E-2 2E-3 0]);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_25">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetOrds">SCgetOrds</a>, <a href="#SCupdateMagnets">SCupdateMagnets</a>, <a href="#SCsanityCheck">SCsanityCheck</a>, <a href="#SCapplyErrors">SCapplyErrors</a>,
<a href="#SCregisterSupport">SCregisterSupport</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCregisterSupport">SCregisterSupport</h3>
<div class="sect3">
<h4 id="_name_52">NAME</h4>
<div class="paragraph">
<p>SCregisterSupport - Register magnet support structures in SC</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_51">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCregisterSupport(SC, type, ords [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_52">DESCRIPTION</h4>
<div class="paragraph">
<p>Initializes magnet support structures such as sections, plinths and girders in SC. The function
input be given as name-value pairs, starting with the structure type and structure ordinates
defining start- end endpoints. Optional arguments are set as the uncertainties of e.g. girder
offsets in the sigma structure <code>SC.SIG.Support</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_12">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The SC base structure.</p>
</dd>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>String specifying the support structure type. Valid are 'Plinth', 'Girder' or 'Section'.</p>
</dd>
<dt class="hdlist1"><code>ords</code></dt>
<dd>
<p><code>[2xN]</code> array of ordinates defining start and end locations of <code>N</code> registered support structures.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_24">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The base structure containing required information of support structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_35">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'Offset'</code></dt>
<dd>
<p>A [1x3] array defining horizontal, vertical and longitudinal offset uncertainties for the start
points or [2x3] array defining horizontal, vertical and longitudinal offset uncertainties for
the start end endpoints. If end points have dedicated uncertainties, <a href="#SCapplyErrors">SCapplyErrors</a> applies
random offset errors of both start end endpoints of the corresponding support structure,
effectively tilting the support structure.
If only start points have asigned uncertainties, <a href="#SCapplyErrors">SCapplyErrors</a> applies to the support
structure endpoints the same offset error as to the start points, resulting in a paraxial
translation of the element. Only in this case dedicated <code>'Roll'</code> uncertainties may be given which
then tilt the structure around it&#8217;s center.
The actual magnet or BPM offsets resulting from the support structure offsets is calculated in
<a href="#SCupdateSupport">SCupdateSupport</a> by interpolating on a straight line between girder start- and endpoints. Note
that the coordinate system change due to bending magnets are ignored in this calculation. Thus,
the accuracy of the result is limited if dipole magnets are involved. This may be particularly
true in case of large sections and/or longitudinal offsets.</p>
</dd>
<dt class="hdlist1"><code>'Roll'</code></dt>
<dd>
<p>[1x3] array [az,ax,ay] defining roll (around z-axis), pitch (roll around x-axis) and yaw (roll
around y-axis) angle uncertainties.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>By default a 2 sigma cutoff is applied. The user can specify a different cutoff by giving the
uncertainty as a cell structure, e.g. {[1x3],nSig}, with nSig being the cutoff (see examples below).</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_24">EXAMPLES</h4>
<div class="paragraph">
<p>Registers the girder start end endpoints defined in <code>ords</code> and assigns the horizontal,
vertical and longitudinal girder offset uncertainties <code>dX</code>, <code>dY</code> and <code>dZ</code>, respectively, to the
girder start points. When the support errors are applied the girder endpoints will get the same
offset error as the start points, resulting in a paraxial translation of the girder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterSupport(SC,'Girder',ords,'Offset',[dX dY dZ]);</pre>
</div>
</div>
<div class="paragraph">
<p>Registers the girder start end endpoints defined in <code>ords</code> and assigns the horizontal,
vertical and longitudinal girder offset uncertainties <code>dX</code>, <code>dY</code> and <code>dZ</code>, respectively, to the
girder start points with a cutoff value of 3 sigma. When the support errors are applied the girder
endpoints will get the same offset error as the start points, resulting in a paraxial translation
of the girder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterSupport(SC,'Girder',ords,'Offset',{[dX dY dZ],3});</pre>
</div>
</div>
<div class="paragraph">
<p>Registers the section start- end endpoints defined in <code>ords</code> and assigns the horizontal and
vertical section offset uncertainties <code>dX</code> and <code>dY</code>, respectively, to the start points. When
the support errors are applied the section endpoints will get the same offset as the start points.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterSupport(SC,'Section',ords,'Offset',[dX dY 0]);</pre>
</div>
</div>
<div class="paragraph">
<p>Registers the girder start end endpoints defined in <code>ords</code>, assigns the roll uncertainty <code>dPhi</code>
and the horizontal and vertical girder offset uncertainties <code>dX1</code> and <code>dY1</code>, respectively to the
start points and <code>dX2</code> and <code>dY2</code> to the endpoints. When the support errors are applied, all
girder start- and endpoints will get random offset errors and the resulting yaw and pitch angles
are calculated accordingly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterSupport(SC,'Girder',ords,'Offset',[dX1 dY1 0; dX2 dY2 0],'Roll',[dPhi 0 0]);</pre>
</div>
</div>
<div class="paragraph">
<p>Registers the girder start end endpoints defined in <code>ords</code> and assigns the horizontal,
vertical and longitudinal girder offset uncertainties <code>dX</code>, <code>dY</code> and <code>dZ</code>, respectively, and the
roll, pitch and yaw angle uncertainties <code>az</code>, <code>ax</code> and <code>ay</code>. When the support errors are applied
the girders will experience a paraxial translation according to the offsets plus the proper
rotations around the three x-, y- and z-axes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCregisterSupport(SC,'Girder',ords,'Offset',[dX dY dZ],'Roll',[az ax ay]);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_26">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCgetOrds">SCgetOrds</a>, <a href="#SCupdateSupport">SCupdateSupport</a>, <a href="#SCgetSupportOffset">SCgetSupportOffset</a>, <a href="#SCplotSupport">SCplotSupport</a>, <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCgetTransformation">SCgetTransformation</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsanityCheck">SCsanityCheck</h3>
<div class="sect3">
<h4 id="_name_53">NAME</h4>
<div class="paragraph">
<p>SCsanityCheck - Checks if the current registration looks reasonable</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_52">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SCsanityCheck(SC)</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_53">DESCRIPTION</h4>
<div class="paragraph">
<p>Performs a sanity check on the current <code>SC</code> structure adn returns warnings if things look fishy.
If you find something that is missing please contact us.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_33">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_27">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCregisterBPMs">SCregisterBPMs</a>, <a href="#SCregisterCAVs">SCregisterCAVs</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCscaleCircumference">SCscaleCircumference</h3>
<div class="sect3">
<h4 id="_name_54">Name</h4>
<div class="paragraph">
<p>SCscaleCircumference - scales the circumference of a ring</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_53">Synopsis</h4>
<div class="paragraph">
<p><code>RING = SCscaleCircumference(RING, circ [, mode])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_54">Description</h4>
<div class="paragraph">
<p>The circumference of <code>RING</code> is changed by scaling the lengths of the drift
spaces in the lattice.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mode">MODE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'abs'</code> (default)</dt>
<dd>
<p>The current circumference is scaled to the value <code>circ</code>.</p>
</dd>
<dt class="hdlist1"><code>'rel'</code></dt>
<dd>
<p>The current circumference is scaled by the value <code>circ</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_25">Return Value</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>Lattice with new circumference.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsetCMs2SetPoints">SCsetCMs2SetPoints</h3>
<div class="sect3">
<h4 id="_name_55">NAME</h4>
<div class="paragraph">
<p>SCsetCMs2SetPoints - Sets dipole corrector magnets to different setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_54">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCsetCMs2SetPoints(SC, CMords, setpoints, nDim [, mode])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_55">DESCRIPTION</h4>
<div class="paragraph">
<p>Sets horizontal or vertical CMs as specified in <code>CMords</code> and <code>nDim</code>, respectively, to <code>setpoints</code>
[rad] and updates the magnetic fields. If the corresponding setpoint exceeds the CM limit
specified in the corresponding lattice field <code>CMlimit</code>, the CM is clipped to that value
and a warning is being printed (to switch off, use <code>warning('off','SC:CM1'))</code>. Positive setpoints
will results in kicks in the positive horizontal or vertical direction.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_34">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>CMords</code></dt>
<dd>
<p>Array of CM ordinates in the lattice structure</p>
</dd>
<dt class="hdlist1"><code>setpoints</code></dt>
<dd>
<p>CM setpoints (array or single value for all CMs) [rad]</p>
</dd>
<dt class="hdlist1"><code>nDim</code></dt>
<dd>
<p>Integer specifying CM dimension ([1|2] &#8594; [hor|ver])</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_19">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The lattice structure with modified and applied setpoints</p>
</dd>
<dt class="hdlist1"><code>setpoints</code></dt>
<dd>
<p>The list of acutal setpoints applied to the magnets after possible clipping [rad]</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_mode_2">MODE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'abs'</code> (default)</dt>
<dd>
<p>Use absolute setpoints</p>
</dd>
<dt class="hdlist1"><code>'rel'</code></dt>
<dd>
<p>Use setpoints relative to current value</p>
</dd>
<dt class="hdlist1"><code>'add'</code></dt>
<dd>
<p>Add setpoints to current value</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_25">EXAMPLES</h4>
<div class="paragraph">
<p>Set all registered horizontal CMs to zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCsetCMs2SetPoints(SC,SC.ORD.CM{1},0,1);</pre>
</div>
</div>
<div class="paragraph">
<p>Add 10urad to the fourth registered vertical CM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCsetCMs2SetPoints(SC,SC.ORD.CM{2}(4),1E-5, 2,'add');</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_globals_5">GLOBALS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>isExp</code></dt>
<dd>
<p>Specify if a real machine is being used, so that a custom user defined
function is being called instead</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_28">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCsetMags2SetPoints">SCsetMags2SetPoints</a>, <a href="#SCupdateMagnets">SCupdateMagnets</a>, <a href="#SCgetCMSetPoints">SCgetCMSetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsetCavs2SetPoints">SCsetCavs2SetPoints</h3>
<div class="sect3">
<h4 id="_name_56">NAME</h4>
<div class="paragraph">
<p>SCsetCavs2SetPoints - Set RF properties to setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_55">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCsetCavs2SetPoints(SC, CAVords, type, setpoints [, mode])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_56">DESCRIPTION</h4>
<div class="paragraph">
<p>Set the setpoints of <code>Voltage</code>, <code>Frequency</code> or <code>TimeLag</code> as specified in <code>'type'</code> of the rf
cavities specified in <code>CAVords</code>. If only a single setpoint is given for multiple cavities,
the setpoint is applied to all cavities.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_35">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure</p>
</dd>
<dt class="hdlist1"><code>CAVords</code></dt>
<dd>
<p>Array of cavity ordinates in the lattice structure</p>
</dd>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>String ('Voltage', 'Frequency' or 'TimeLag') specifying which cavity field should be set.</p>
</dd>
<dt class="hdlist1"><code>setpoints</code></dt>
<dd>
<p>Setpoints (array or single value for all cavities)</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_mode_3">MODE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'abs'</code> (default)</dt>
<dd>
<p>Use absolute setpoint</p>
</dd>
<dt class="hdlist1"><code>'rel'</code></dt>
<dd>
<p>Use relative setpoint to current value</p>
</dd>
<dt class="hdlist1"><code>'add'</code></dt>
<dd>
<p>Add setpoints to current value</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_26">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The modified SC structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_26">EXAMPLES</h4>
<div class="paragraph">
<p>Sets the time lag of all cavities registered in SC to zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCsetCavs2SetPoints(SC, SC.ORD.Cavity, 'TimeLag', 0);</pre>
</div>
</div>
<div class="paragraph">
<p>Adds 1kHz to the frequency of the first cavity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SC = SCsetCavs2SetPoints(SC, SC.ORD.Cavity(1), 'Frequency', 1E3, 'add');</pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsetMags2SetPoints">SCsetMags2SetPoints</h3>
<div class="sect3">
<h4 id="_name_57">NAME</h4>
<div class="paragraph">
<p>SCsetMags2SetPoints - Sets magnets to setpoints</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_56">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCsetMags2SetPoints(SC, MAGords, type, order, setpoints [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_57">DESCRIPTION</h4>
<div class="paragraph">
<p>Sets magnets (except CMs) as specified in <code>MAGords</code> to <code>setpoints</code> while <code>order</code> and <code>type</code> defines
which field entry should be used (see below). The setpoints may be given relative to their nominal
value or in absolute terms. If the considered quadrupole is a combined function magnet with
non-zero bending angle and the kick compensation flag is switched on, the appropriate bending
angle difference is calculated and the horizontal CM setpoint is changed accordingly to compensate
for that dipole kick difference.
If the setpoint of a skew quadrupole exceeds the limit specified in the corresponding lattice
field <code>SkewQuadLimit</code>, the setpoint is clipped to that value and a warning is being printed (to
switch off, use <code>warning('off','SC:SkewLim')</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_36">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC base structure.</p>
</dd>
<dt class="hdlist1"><code>MAGords</code></dt>
<dd>
<p>Magnet ordinates in the lattice structure.</p>
</dd>
<dt class="hdlist1"><code>order</code></dt>
<dd>
<p>Numeric value defining the order of the considered magnet: [1,2,3,&#8230;&#8203;] &#8658; [dip,quad,sext,&#8230;&#8203;]</p>
</dd>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>Numeric value defining the type of the considered magnet: [1,2] &#8658; [skew/normal]</p>
</dd>
<dt class="hdlist1"><code>setpoints</code></dt>
<dd>
<p>Magnet setpoints, either single value applied to all magnets or [1 x N] array
matching the number of magnets specified in <code>MAGords</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_36">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'method'</code> (<code>'abs'</code>)</dt>
<dd>
<p>Specifies how the setpoints should be applied. Possible are</p>
<div class="ulist">
<ul>
<li>
<p><code>'abs'</code>: Applies the setpoints specified in <code>setpoints</code>.</p>
</li>
<li>
<p><code>'rel'</code>: Applies the setpoints specified in <code>setpoints</code> relative to the nominal setpoints of
the considered magnets.</p>
</li>
<li>
<p><code>'add'</code>: Adds the setpoints specified in <code>setpoints</code> to the current setpoints of the
considered magnets.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>'dipCompensation'</code> (0)</dt>
<dd>
<p>	Used for combined function magnets. If this flag is set and if there is a horizontal CM
registered in the considered magnet, the CM is used to compensate the bending angle difference
if the applied quadrupole setpoints differs from the design value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_20">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The base structure containing lattice with modified and applied setpoints.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_27">EXAMPLES</h4>
<div class="paragraph">
<p>Identify the ordinates of all elements named <code>'SF'</code> and switch their sextupole component off.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'SF');
SC = SCsetMags2SetPoints(SC,ords,2,3,0,'method','abs');</pre>
</div>
</div>
<div class="paragraph">
<p>Identify the ordinates of all elements named <code>QF</code> and <code>QD</code> and set their quadrupole component
to 99% of their design value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'QF|QD');
SC = SCsetMags2SetPoints(SC,ords,2,2,0.99,'method','rel');</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_29">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCupdateMagnets">SCupdateMagnets</a>, <a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsetMultipoles">SCsetMultipoles</h3>
<div class="sect3">
<h4 id="_name_58">NAME</h4>
<div class="paragraph">
<p>SCsetMultipoles - sets multipole errors in lattice elements</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_57">SYNOPSIS</h4>
<div class="paragraph">
<p><code>RING = SCsetMultipoles(RING, ords, AB [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_58">DESCRIPTION</h4>
<div class="paragraph">
<p>Applies multipole errors specified in <code>AB</code> in the lattice elements <code>ords</code> of <code>RING</code> depending on
the specified options.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_37">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RING</code></dt>
<dd>
<p>Lattice cell structure.</p>
</dd>
<dt class="hdlist1"><code>ords</code></dt>
<dd>
<p>Ordinates of the considered magnets.</p>
</dd>
<dt class="hdlist1"><code>AB</code></dt>
<dd>
<p>[N x 2] array of PolynomA/B multipole errors.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_37">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'method'</code> (<code>'rnd'</code>)</dt>
<dd>
<p>Specifies which multipole error method should be applied. Possible are</p>
<div class="ulist">
<ul>
<li>
<p><code>'sys'</code>:   This option is intended for normalized systematic multipole error tables. It sets
the systematic multipoles of the field component defined by option <code>'order'</code>
and <code>'type'</code>. It is required that the <code>AB</code> entries are normalized by that component,
e.g. <code>AB(2,1)=1</code> for skew-quadrupole systematic multipoles. The systematic
multipoles are from now on scaled with the current magnet excitation and added to the
PolynomA/B fields.</p>
</li>
<li>
<p><code>'rnd'</code>:   This option is intended for random multipole error tables. It randomly generates
multipole components with a 2-sigma truncated Gaussian distribution from each of
the <code>AB</code> entries. The final multipole errors are stored in the PolynomA/BOffset of
the lattice elements.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>'order'</code> ([])</dt>
<dd>
<p>Numeric value defining the order of the considered magnet: [1,2,3,&#8230;&#8203;] &#8658; [dip,quad,sext,&#8230;&#8203;]</p>
</dd>
<dt class="hdlist1"><code>'type'</code> ([])</dt>
<dd>
<p>Numeric value defining the type of the considered magnet: [1,2] &#8658; [skew/normal]</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_examples_28">EXAMPLES</h4>
<div class="paragraph">
<p>Defines random multipole components for the 'QF' magnet and adds it to the field offsets of all
magnets named 'QF'.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'QF');
AB = [0 1E-5;...
0 1E-4;...
0 0;...
0 1E-2];
RING = SCsetMultipoles(RING,ords,AB,'method','rnd');</pre>
</div>
</div>
<div class="paragraph">
<p>Reads the normalized systematic multipole components for the skew quadrupole excitation of the 'SF'
magnet from table 'SF_skew_quad_AT_norm.tsv' and assigns it to all magnets named 'SF'. Note that
the data table in 'SF_skew_quad_AT_norm.tsv' must be 1.0 for the skew quadrupole component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ords = SCgetOrds(SC.RING,'SF');
[AB,order,type] = SCmultipolesRead('SF_skew_quad_AT_norm.tsv');
RING = SCsetMultipoles(RING,ords,AB,'method','sys','order',order,'type',type);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_30">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCmultipolesRead">SCmultipolesRead</a>, <a href="#SCupdateMagnets">SCupdateMagnets</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsynchEnergyCorrection">SCsynchEnergyCorrection</h3>
<div class="sect3">
<h4 id="_name_59">NAME</h4>
<div class="paragraph">
<p>SCsynchEnergyCorrection - Calculates a beam based correction to the rf frequency</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_58">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[deltaF, ERROR] = SCsynchEnergyCorrection(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_59">DESCRIPTION</h4>
<div class="paragraph">
<p>Changes the cavity frequency within the user defined interval and evaluates the mean
turn-by-turn horizontal BPM deviation. A straight line is fitted to the data and the zero crossing
is identified. It is assumed that the beam is injected relatively close to the synchronous phase.
Then, for sufficiently small number of turns the synchrotron motion results in a mean turn-by-turn
energy deviation which is zero if the synchronous energy defined by the rf frequency matches
the injected beam energy. The number of evaluated turns should be smaller than synchrotron period.
Note that if more than one cavity is specified the same frequency steps are
applied to all cavities. Not also that results might be compromised if the beam transmission
differs significantly throughout the different applied frequency steps.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_38">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_38">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'cavOrd'</code> (<code>SC.ORD.Cavity</code>)</dt>
<dd>
<p>Ordinate of evaluated cavity</p>
</dd>
<dt class="hdlist1"><code>'range'</code> (<code>[-1E3,1E3]</code>)</dt>
<dd>
<p>Frequency range [Hz]</p>
</dd>
<dt class="hdlist1"><code>'nSteps'</code> (<code>15</code>)</dt>
<dd>
<p>Number of frequency steps to be evaluated</p>
</dd>
<dt class="hdlist1"><code>'nTurns'</code> (<code>150</code>)</dt>
<dd>
<p>Number of turns to be evaluated</p>
</dd>
<dt class="hdlist1"><code>'minTurns'</code> (<code>50</code>)</dt>
<dd>
<p>Minimum number of turns the beam has to survive in order to be included in the calculation.</p>
</dd>
<dt class="hdlist1"><code>'plotResults'</code> (<code>0</code>)</dt>
<dd>
<p>If true, results are plotted.</p>
</dd>
<dt class="hdlist1"><code>'plotProgress'</code> (<code>0</code>)</dt>
<dd>
<p>If true, each frequency step is plotted.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (<code>0</code>)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_21">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>deltaF</code></dt>
<dd>
<p>Frequency correction step to be added to cavity frequency.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors_5">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>All good.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>Horizontal TBT BPM deviation shows no zero crossing</p>
</dd>
<dt class="hdlist1"><code>2</code></dt>
<dd>
<p>Sinusoidal fit function shows no zero crossing</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_31">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCsetCavs2SetPoints">SCsetCavs2SetPoints</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsynchEnergyCorrection">SCsynchEnergyCorrection</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCsynchPhaseCorrection">SCsynchPhaseCorrection</h3>
<div class="sect3">
<h4 id="_name_60">NAME</h4>
<div class="paragraph">
<p>SCsynchPhaseCorrection - Calculates a beam based correction to the rf cavity phase</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_59">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[deltaPhi, ERROR] = SCsynchPhaseCorrection(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_60">DESCRIPTION</h4>
<div class="paragraph">
<p>Changes the cavity phase within the phase interval [-pi,pi] stepwise and evaluates the mean
turn-by-turn horizontal BPM deviation. A sinusoidal function is fitted to the data and the zero
crossing is identified. It is assumed that for sufficiently small number of turns the synchrotron
motion is negligible and injection at the synchronous phase will result in zero turn-by-turn
energy variation. Thus, the horizontal turn-by-turn BPM readings should in first approximation not
differ. The number of evaluated turns should be significantly smaller than half a sunchrotron
period. Note that if more than one cavity is specified the same phase steps are applied to all
cavities. Results might be compromised.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_39">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>The SC base structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_39">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'cavOrd'</code> (<code>SC.ORD.Cavity</code>)</dt>
<dd>
<p>Ordinate of evaluated cavity</p>
</dd>
<dt class="hdlist1"><code>'nSteps'</code> (<code>30</code>)</dt>
<dd>
<p>Number of phase steps to be evaluated</p>
</dd>
<dt class="hdlist1"><code>'nTurns'</code> (<code>30</code>)</dt>
<dd>
<p>Number of turns to be evaluated</p>
</dd>
<dt class="hdlist1"><code>'plotResults'</code> (<code>0</code>)</dt>
<dd>
<p>If true, results are plotted.</p>
</dd>
<dt class="hdlist1"><code>'plotProgress'</code> (<code>0</code>)</dt>
<dd>
<p>If true, each phase step is plotted.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (<code>0</code>)</dt>
<dd>
<p>If true, debug information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_22">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>deltaPhi</code></dt>
<dd>
<p>Phase correction step to be added to cavity field 'TimeLag'.</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors_6">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>All good.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>Horizontal TBT BPM deviation shows no zero crossing</p>
</dd>
<dt class="hdlist1"><code>2</code></dt>
<dd>
<p>Sinusoidal fit function shows no zero crossing</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_32">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCsetCavs2SetPoints">SCsetCavs2SetPoints</a>, <a href="#SCgetBPMreading">SCgetBPMreading</a>, <a href="#SCsynchEnergyCorrection">SCsynchEnergyCorrection</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCtuneScan">SCtuneScan</h3>
<div class="sect3">
<h4 id="_name_61">NAME</h4>
<div class="paragraph">
<p>SCtuneScan - Varies quadrupole families to improve beam transmission.</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_60">SYNOPSIS</h4>
<div class="paragraph">
<p><code>[qSP, SC, maxTurns, finTrans, ERROR] = SCtuneScan(SC, qOrds, qSPvec [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_61">DESCRIPTION</h4>
<div class="paragraph">
<p>Varies two quadrupole groups specified in cell array <code>qOrds</code> on a grid of relative setpoints specified in
<code>qSPvec</code> in a spiral-like pattern to increase the beam transmission. Returns the relative setpoints
which satisfied the target condition or, if the target could not be reached the values which
resulted in best transmission.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inputs_40">INPUTS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p><code>SC</code> base structure</p>
</dd>
<dt class="hdlist1"><code>qOrds</code></dt>
<dd>
<p><code>[1x2]</code> cell array of quadrupole ordinates {<code>[1 x NQ1],[1 x NQ2]</code>}</p>
</dd>
<dt class="hdlist1"><code>qSPvec</code></dt>
<dd>
<p><code>[1x2]</code> cell array of quadrupole setpoints {<code>[SP1_1,&#8230;&#8203;,SP1_N1],[SP2_1,&#8230;&#8203;,SP2_N2]</code>} with <code>N2=N1</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_40">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'nParticles'</code> (<code>SC.INJ.nParticles</code>)</dt>
<dd>
<p>Number of particles used for tracking.</p>
</dd>
<dt class="hdlist1"><code>'nTurns'</code> (<code>SC.INJ.nTurns</code>)</dt>
<dd>
<p>Number of turns used for tracking.</p>
</dd>
<dt class="hdlist1"><code>'target'</code> (<code>1</code>)</dt>
<dd>
<p>Transmission target at <code>'nTurns'</code>.</p>
</dd>
<dt class="hdlist1"><code>'fullScan'</code> (0)</dt>
<dd>
<p>If false, the scan finishes as soon as the target is reached.</p>
</dd>
<dt class="hdlist1"><code>'plotFlag'</code> (0)</dt>
<dd>
<p>If true, beam transmission is plotted at every step.</p>
</dd>
<dt class="hdlist1"><code>'verbose'</code> (0)</dt>
<dd>
<p>If true, additional information is printed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_values_23">RETURN VALUES</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>qSP</code></dt>
<dd>
<p>Final setpoints of quadrupole families (relative to current values)</p>
</dd>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>SC structure with applied setpoints</p>
</dd>
<dt class="hdlist1"><code>maxTurns</code></dt>
<dd>
<p>Array of achieved turns matching the scanning pattern</p>
</dd>
<dt class="hdlist1"><code>finTrans</code></dt>
<dd>
<p>Array of turn-by-turn beam transmission matching the scanning pattern</p>
</dd>
<dt class="hdlist1"><code>ERROR</code></dt>
<dd>
<p>Error value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_errors_7">ERRORS</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>Beam transmission target reached.</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>Beam transmission or number of turns increased, target not reached.</p>
</dd>
<dt class="hdlist1"><code>2</code></dt>
<dd>
<p>Unable to increase beam transmission.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_33">SEE ALSO</h4>
<div class="paragraph">
<p><strong>getBPMReading()</strong>, <strong>SCgenBunches()</strong></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCupdateCAVs">SCupdateCAVs</h3>
<div class="sect3">
<h4 id="_name_62">NAME</h4>
<div class="paragraph">
<p>SCupdateCAVs - Updates the cavities in the lattice</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_61">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCupdateCAVs(SC [, ords])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_62">DESCRIPTION</h4>
<div class="paragraph">
<p>Updates the cavity fields <code>Voltage</code>, <code>Frequency</code> and <code>TimeLag</code> in <code>SC.RING</code> as specified in <code>ords</code>.
If no ordinates are given explicitly, all registered cavities defined in <code>SC.ORD.Cavity</code> are
updated. For each cavity and each field, the setpoints, calibration errors and offsets are considered.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_13">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>Base structure.</p>
</dd>
<dt class="hdlist1"><code>ords</code> (optional)</dt>
<dd>
<p>Cavity ordinates to be updated.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_27">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>Base structure with updated cavities.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_34">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterCAVs">SCregisterCAVs</a>, <a href="#SCapplyErrors">SCapplyErrors</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCupdateMagnets">SCupdateMagnets</h3>
<div class="sect3">
<h4 id="_name_63">NAME</h4>
<div class="paragraph">
<p>SCupdateMagnets - Updates the magnetic fields in RING</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_62">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCupdateMagnets(SC [, ords])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_63">DESCRIPTION</h4>
<div class="paragraph">
<p>Updates the magnets specified in <code>RING</code> as specified in <code>ords</code>. If no ordinates are given
explicitly, all registered magnets defined in <code>SC.ORD.Magnet</code> are updated. For each magnet the
setpoints (<code>SetPointA/B</code>) and calibration errors (<code>CalErrorA/B</code>) are evaluated.
If systematic multipole components are specified, e.g. in <code>SysPolBFromB</code> for systematic
PolynomB-multipoles induced by PolynomB entries, the corresponding multipole components are scaled
by the current magnet excitation and added, as well as static field offsets (if specified in
<code>PolynomA/BOffset</code>).
If the considered magnet has a bending angle error (from pure bending angle eror or due to a
combined function magnet), the corresponding horizontal dipole magnetic field is calculated and
added to the PolynomB(1) term. It is thereby assured that a dipole error doesn&#8217;t alter the
coordinate system.</p>
</div>
<div class="paragraph">
<p>If the considered magnet is registered as a slpit magnet (<code>'MasterOf'</code>), the errors and setpoints
of the master magnet are applied to the fields of the child magnets. Note that split quadrupole
magnets with different gradients, however, or split CMs can currently not be updated correctly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_28">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>Base structure with updated magnets.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_35">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterMagnets">SCregisterMagnets</a>, <a href="#SCapplyErrors">SCapplyErrors</a>, <a href="#SCsetMultipoles">SCsetMultipoles</a>, <a href="#SCsetMags2SetPoints">SCsetMags2SetPoints</a>, <a href="#SCsetCMs2SetPoints">SCsetCMs2SetPoints</a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="SCupdateSupport">SCupdateSupport</h3>
<div class="sect3">
<h4 id="_name_64">NAME</h4>
<div class="paragraph">
<p>SCupdateSupport - updates the misalignments resulting from the support structure</p>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_63">SYNOPSIS</h4>
<div class="paragraph">
<p><code>SC = SCupdateSupport(SC [, options])</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_description_64">DESCRIPTION</h4>
<div class="paragraph">
<p>This function updates the offsets and rolls of the elements in <code>SC.RING</code>
based on the current support errors, by setting the lattice fields <code>T1</code>, <code>T2</code>, and
<code>R1</code>, <code>R2</code> for magnets and the fields <code>SupportOffset</code> and <code>SupportRoll</code> for BPMs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_input_14">INPUT</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code></dt>
<dd>
<p>Initial <code>SC</code> base structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_options_41">OPTIONS</h4>
<div class="paragraph">
<p>The following options can be given as name/value-pairs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>'BPMstructOffset'</code> (<code>1</code>)</dt>
<dd>
<p>If true, BPM offsets are updated.</p>
</dd>
<dt class="hdlist1"><code>'MAGstructOffset'</code> (<code>1</code>)</dt>
<dd>
<p>If true, magnet offsets are updated.</p>
</dd>
<dt class="hdlist1"><code>'ords'</code> ([])</dt>
<dd>
<p>List of ordinates at which misalignments should be updated. If empty, all magnets and BPMs are updated.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_return_value_29">RETURN VALUE</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SC</code> </dt>
<dd>
<p>Base structure with updated <code>SC.RING</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_see_also_36">SEE ALSO</h4>
<div class="paragraph">
<p><a href="#SCregisterSupport">SCregisterSupport</a>, <a href="#SCgetSupportOffset">SCgetSupportOffset</a>, <a href="#SCgetSupportRoll">SCgetSupportRoll</a>, <a href="#SCplotSupport">SCplotSupport</a></p>
</div>
<hr>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-01-06 12:25:15 +0100
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>